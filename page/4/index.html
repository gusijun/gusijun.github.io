<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"b2t":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="思君の博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="思君の博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="顾思君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>思君の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="思君の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思君の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">40</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B64/" class="post-title-link" itemprop="url">进阶4</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:21:00" itemprop="dateModified" datetime="2020-02-12T15:21:00+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>方法覆盖：overrride ,overwriter</p>
<p>　1.什么时候方法需要重写？</p>
<p>　　如果父类中的方法已经无法满足当前子类的业务要求，需要将父类的方法进行重写</p>
<p>　2.子类如果重写父类中的方法之后,子类对象一定调用的是重写之后的方法。</p>
<p>　3.发生方法覆盖的条件：</p>
<p>　　第一：发生在具有继承关系的两个类之间</p>
<p>　　第二：必须具有相同的方法名,相同的返回值类型,相同的参数列表</p>
<p>　　第三：重写的方法不能比被重写的方法拥有更低的访问权限</p>
<p>　　第四：重写的方法不能比被重写的方法抛出更宽泛的异常</p>
<p>　　第五：私有的方法不能被覆盖</p>
<p>　　第六：构造方法无法被覆盖，因为构造方法无法被继承</p>
<p>　　第七：静态的方法不存在覆盖</p>
<p>　　　　（静态方法执行和对象无关）</p>
<p>　　第八：覆盖指的是成员方法，和成员变量无关</p>
<p>　4.继承的基本作用：代码复用。继承最重要的作用：方法重写</p>
<p>　关于java语言中向上转型和向下转型</p>
<p>　　1.向上转型(upcasting):  子 –&gt; 父</p>
<p>　　2.向下转型(downcasting):父 –&gt; 子</p>
<p>注意：无论是向上转型还是向下转型,两个类之间必须有继承关系</p>
<p>多态作用：使用多态可以使代码之间的耦合度降低</p>
<p>　　　　　项目扩展能力增强<br>耦合度：代码和代码之间的关联程度</p>
<p>super</p>
<p>　1.super不是引用类型，super中存储的不是内存地址,super指向的不是父类对象</p>
<p>　2.super代表的是当前子类对象中的父类型特征</p>
<p>　3.什么时候使用super？</p>
<p>　　子类和父类中都有某个数据,例如,子类和父类中都有name这个属性</p>
<p>　　如果要在访问子类中父类中的属性，需要使用super</p>
<p>　4.super可以用在什么地方？</p>
<p>　　成员方法</p>
<p>　　构造方法</p>
<p>super关键字用在构造方法中：<br>语法:super(实参)；<br>作用：通过子类的构造方法去调用父类的构造方法</p>
<p>语法规则：一个构造方法第一行如果没有this(…)，也没有显示的去调用super(…);</p>
<p>　　　　　系统会默认调用super();<br>注意：super（…）的调用只能方在构造方法的第一行<br>super(…)和this(…)不能共存</p>
<p>通过子类的构造方法去调用父类的构造方法：作用是：给当前子类对象中的父类型特征赋值。</p>
<p>如何定义抽象类？</p>
<ul>
<li><p>class关键字前abstract</p>
</li>
<li><p>抽象类无法实例化</p>
</li>
<li><p>虽然抽象类没有办法实例化,但是抽象类也有构造方法，该构造方法是给子类创建对象的用的</p>
</li>
<li><p>抽象类中可以定义抽象方法：</p>
</li>
<li><p>抽象方法的语法：在方法的修饰列表中添加abstract关键字,并且抽象方法应该以“；”结束,不能带有“{}”</p>
</li>
<li><p>例如：public abstract void m();</p>
</li>
<li><p>5.抽象类中不一定有抽象方法，但抽像方法所在的类必须是抽象类</p>
</li>
<li><p>一个非抽象的类继承抽象类，必须将抽象类中的抽象方法覆盖，实现，重写。</p>
<p>抽像类不能被final修饰<br>抽象方法不能被final修饰</p>
</li>
</ul>
<p>final修饰的类无法被继承<br>final修饰的方法无法被重写<br>final修饰的局部变量一旦赋值不可再改变<br>final修饰的成员变量需要手动赋值<br>final修饰的成员变量和static联用称为常量<br>深入final</p>
<p>　　final修饰的引用类型,该引用不可重新指向其他的java对象</p>
<p>　　但是final修饰的引用,该引用指向的对象的属性是可以修改的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B65/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B65/" class="post-title-link" itemprop="url">进阶5</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:24:47" itemprop="dateModified" datetime="2020-02-12T15:24:47+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接口也是一种引用类型，可以等同看做类</p>
<ul>
<li>如何定义接口，语法：</li>
</ul>
<p>　　[修饰符]  interface  接口名{}</p>
<ul>
<li>接口中只能出现常量和抽象方法</li>
<li>接口其实是一个特殊的抽象类，特殊在接口是完全抽象的</li>
<li>接口中没有构造方法,接口无法被实例化</li>
<li>接口与接口之间可以多继承</li>
<li>一个类可以实现多个接口（这里的实现可以等同看成继承）</li>
<li>一个非抽象的类实现接口,需要将接口中所有的方法“实现/重写/覆盖”</li>
</ul>
<p>接口中的常量public static final<br>接口中的抽象方法public abstract<br>implements是实现的意思,是一个关键字<br>implements和extends意义相同</p>
<p>接口作用： </p>
<p>　1.可以使项目分层,所有层都面向接口开发，开发效率提高了</p>
<p>　2.接口使代码和代码之间的耦合度降低，就像内存条和主板的关系，变得“可插拔”，可以随意切换</p>
<p>　　接口和抽象类都能完成某个功能，优先选择接口</p>
<p>　　因为接口可以多实现，多继承</p>
<p>　　并且一个类除了实现接口之外，还可以去继承其他类，保留了类的继承</p>
<p>Object </p>
<p>　toString 以字符串的形式返回java对象</p>
<p>　类名@java对象在堆中的内存地址（哈希算法转成16进制）</p>
<p>equals</p>
<p>　finalize方法什么时候调用？</p>
<p>　　1.finalize方法每个java对象都有</p>
<p>　　2.finalize方法不需要程序员去调用,由系统调用</p>
<p>　　3.java对象如果没有更多的引用指向它，则该java对象成为垃圾数据<br>       等待垃圾回收器的回收,垃圾回收器在回收这个java对象之前会自动<br>       调用该对象的finalize方法</p>
<p>　finalize方法时该对象马上就要回收了,列如：需要释放资源,则可以在该方法中释放</p>
<p>　程序员只能“建议”垃圾回收器回收垃圾</p>
<p>　hashCode返回该对象的哈希码值</p>
<p>　java对象的内存地址经过哈希算法得出的int类型的数值</p>
<p>　clone 数据的副本</p>
<p>软件包机制：</p>
<p>　1.为了解决类的命名冲突问题，在类前加命名空间（包机制）</p>
<p>　2.在java中使用package语句定义包（单包，复包）</p>
<p>　3.package语句只能出现在.java源文件的第一行</p>
<p>　4.package定义的格式，通常采用公司域名倒叙方式：</p>
<p>　例如：com.bjpowernode.oa.system;</p>
<p>　以上包含义：bjpowernode公司开发oa项目,system是oa项目中的一个模块</p>
<p>　5.完整的类名是带有包名的</p>
<p>　6.带有package语句的java源文件必须这样编译</p>
<p>　javac -d 生成路径 java源文件路径<br>　7.运行：</p>
<p>　　java com.bjpowernode.oa.system.A</p>
<p>目录也是类，类的姓</p>
<p>import语句可以引入其他类<br>import语句只能出现在package语句之下,class定义的语句之上<br>java.lang 软件包下所有类不需要手动导入.系统自动导入</p>
<p>关于访问权限修饰符：修饰类，修饰方法，修饰变量</p>
<p>　private     只能在本类中访问</p>
<p>　public      可以在任意位置访问</p>
<p>　protected   本类，同一个包下，不同包下不行，但是子类中可以</p>
<p>　缺省          本类，同一个包下，不同包下不行</p>
<p>关于静态内部类</p>
<p>　1.静态内部类可以等同看做静态变量</p>
<p>　　内部类的重要作用，可以访问外部类中私有的数据</p>
<p>　2.静态内部类可以直接访问外部类的静态数据，无法直接访问成员（静态上下文）</p>
<p>关于成员内部类</p>
<p>　1.成员内部类可以等同看做成员变量</p>
<p>　2.成员内部类不能有静态声明</p>
<p>　3.成员内部类可以访问外部类所有的数据</p>
<p>　局部内部类等同于局部变量</p>
<p>　局部内部类不能用访问控制权限修饰符修饰</p>
<p>　重点：局部内部类在访问局部变量的时候，局部变量必须使用final修饰</p>
<p>匿名内部类：指的是类没有名字</p>
<p>　匿名内部类优点：少定义一个类</p>
<p>　缺点：无法重复使用</p>
<p>泛化 实现 关联</p>
<p>聚合关系：整体不依赖部分，部分也不会依赖整体<br>整体不决定部分的生命周期</p>
<p>合成关系<br>合成关系与聚合关系是相似的，区别的地方在：整体和部分是紧密关联的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B66/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B66/" class="post-title-link" itemprop="url">进阶6</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:34:05" itemprop="dateModified" datetime="2020-02-12T15:34:05+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.异常是什么？</p>
<p>　第一，异常模拟的是现实世界中的不正常“事件”</p>
<p>　第二，java中采用“类”去模拟异常</p>
<p>　第三，类是可以创建对象的</p>
<p>　　NullPointerExeption e = 0x1234;</p>
<p>　　e是引用类型,e中保存的内存地址指向堆中的“对象”</p>
<p>　　这个对象一定是NullPointerException类型</p>
<p>　　这个对象就表示真实存在的异常事件</p>
<p>　　NullPointerException是一类异常</p>
<p>​    “抢劫”就是一类异常<br>​    “张三被抢劫”就是一个异常事件</p>
<p>2.异常机制的作用？</p>
<p>　java语言为我们提供一种完善的异常处理机制，</p>
<p>　作用是：程序发生异常事件之后，为我们输出详细的信息</p>
<p>　程序员通过这个信息，可以对程序进行一些处理，使程序</p>
<p>　更加健壮。</p>
<p>本质：程序执行过程中发生了算术异常这个事件，JVM为我们创建了ArithmeticException类型的对象</p>
<p>　　　并且这个对象中包含了异常的详细信息，并且JVM将这个对象中的信息输出到控制台。</p>
<p>所有Exception的直接子类都是编译型异常（发生的概率比较高）</p>
<p>​     所有编译时异常，要求程序员在编写程序阶段，必须对它进行处理，如果不处理的话</p>
<p>　 编译不通过。处理异常有两种方式，捕捉和声明抛出。捕捉：try…catch…,声明抛出</p>
<p>　 就是在方法声明的位置上使用throws关键字抛出异常。</p>
<p>所有RuntimeException的子类都是运行时异常，运行时异常程序员在编写阶段（发生的概率比较低）</p>
<p>不需要对它进行处理</p>
<p>处理异常有两种方式：</p>
<p>　1.声明抛出 throws</p>
<p>　2.捕捉  try ..catch..</p>
<p>数组： </p>
<ul>
<li>数组是一种引用类型</li>
<li>数组是一种简单的数据结构，线性结构</li>
<li>数组是一个容器，可以用来存储其他元素</li>
<li>数组可以存储任意类型数据结构的元素</li>
<li>数组分为:一维数组，二维数组,三维数组，多维数组</li>
<li>数组中存储的元素类型是统一的</li>
<li>数组长度不可变，数组一旦创建长度不可变的，固定的</li>
</ul>
<p>数组拿首元素的内存地址作为数组对象的内存地址<br>数组中存储元素的类型是统一的，每一个元素在内存中所占的空间大小是相同的，<br>知道数组的首元素内存地址，要查找的元素只要知道下标就可以快速的计算出偏移量<br>通过首元素内存地址+偏移量，快速计算出要查找元素的内存地址，通过内存地址快速<br>定位该元素，所以数组查找元素的效率较高<br>随机的对数组进行增删元素，当增加元素的时候，为了保证数组中元素在空间存储上是有序的，<br>所以被添加元素位置后面的所有元素都要向后移动。删除元素也是，后面所有的元素要向前移动<br>所以数组的增删元素的效率很低</p>
<p>初始化一维数组</p>
<p>　1.静态初始化</p>
<p>　2.动态初始化</p>
<p>　　动态初始化一维数组，会先在堆内存中分配这个数组，并且数组中每一个元素都采用默认值</p>
<p>关于main方法中的参数俩表String[] args</p>
<p>　1.String[] args是专门用来接收命令行参数的</p>
<p>　2.列如：java ArrayTest abc def aaa</p>
<p>　 JVM在调用ArrayTest 的main方法之前先将”abc def aaa”这个字符串以空格的方式分割，然后存储在</p>
<p>　String数组中</p>
<p>关于数组的拷贝</p>
<p>　System.arraycopy</p>
<p>二维数组的特点：</p>
<p>　1.二维数组是一个特殊的一维数组</p>
<p>　2.特殊的一维数组，特殊在一维数组的每一个元素都是“一维数组”</p>
<p>二分法查找：</p>
<p>　1.建立在已经排序的基础上的</p>
<p>　　数组中没有重复元素</p>
<p>java.lang.String</p>
<p>　1.字符串一旦创建不可再改变。“abc”字符串一旦创建,不可变成“abcd”</p>
<p>　2.提升字符串的访问效率，在程序中使用了“缓存”技术，所以在java中所有使用双引号括起来的字符串都会在”字符串常量池”中创建一份</p>
<p>　　字符串常量池在方法区中</p>
<p>　3.在程序执行过程中，如果程序用到某个字符串，例如“abc”，那抹程序会在字符串常量池中搜索字符串，如果没有找到则在字符串常量池中新建一个“abc”字符串，如果找到就直接拿过来用 [字符串常量池是个缓冲区，为了提高字符串的访问效率]</p>
<p>使用String需要注意的问题：尽量不要做字符串频繁拼接的操作<br>因为字符串一旦创建不可改变，只要频繁拼接，就会在字符串常<br>量池中创建大量的字符串对象，给垃圾回收带来问题.</p>
<p>关于字符串常用方法</p>
<ul>
<li>char charAt(int index)</li>
<li>boolean endsWith(String endStr)</li>
<li>boolean equalsIgnoreCase(String anotherString)  判断字符串是否相等，忽略大小写</li>
<li>getBytes</li>
<li>indexOf / indexOf(String str,int fromIndex)</li>
<li>lastIndexOf(String str) / lastIndexOf(Sting fromIndex)  反向搜索</li>
<li>length</li>
<li>String replaceAll(String s1,String s2) </li>
<li>split</li>
<li>boolean startsWith(String s)</li>
<li>String substring(int begin) / String substring(int beginIndex,int endIndex)</li>
<li>char[] toCharArray</li>
<li>toUpperCase</li>
<li>toLowerCase</li>
<li>trim</li>
<li>String valueOf(Object obj)</li>
</ul>
<p>正则表达式</p>
<p>　1.正则表达式是一门独立的学科</p>
<p>　2.正则表达式是一种字符模型，专门做字符串格式匹配的</p>
<p>　3.正则表达式是通用的</p>
<p>java.lang.StringBuffer<br>java.lang.StringBuilder</p>
<p>　1.StringBuffer和StringBuilder是什么？</p>
<p>　　是一个字符串缓冲区</p>
<p>　2.工作原理<br>　　预先在内存中申请一块空间，以容乃字符序列</p>
<p>　　如果预留的空间不够用，则进行自动扩容，以容纳更</p>
<p>　　多字符序列。<br>   3.StringBuffer，StringBuilder和String的最大区别？</p>
<p>　　String是不可变字符序列，存储字符串常量池中</p>
<p>　　StringBuffer底层是一个char数组,但是该char数组是可变的</p>
<p>　　并且可以自动扩容<br>   4.StringBuffer和StringBuilder的默认初始化容量是16<br>   5.如何优化StringBuffer和StringBuilder</p>
<p>　　最好在创建StringBuffer之前，预测StringBuffer的存储字符数量</p>
<p>　　然后再创建StringBuffer的时候采用指定容量的方式创建StringBuffer</p>
<p>　　为了减少底层数组的拷贝，提交效率<br>   6.StringBuffer线程安全</p>
<p>　　StringBuilder线程不安全</p>
<p>Java中八种数据类型对应的包装类型：<br>    基本数据类型                  包装类<br>    byte                          java.lang.Byte<br>    short                         java.lang.Short<br>    int                           Java.lang.Integer<br>    long                          java.lang.Long</p>
<p>​    float                         java.lang.Float<br>​    double                        java.lang.Double</p>
<p>​    boolean                       java.lang.Boolean<br>​    char                          java.lang.Charactor</p>
<p>Integer中的常用方法：<br>    int –&gt; Integer  基本数据类型–&gt;引用数据类型</p>
<p>　　Integer i1 = new Integer(10);<br>    Integer – &gt; int  引用数据类型 –&gt; 基本数据类型</p>
<p>　　 int i2 = i1.intValue();<br>    String –&gt; int 字符串转数字</p>
<p>　　 int i3 = Integer.parseInt(“25”);</p>
<p>toBinaryString     十进制转成2进制<br>toHexString        十进制转成16进制<br>toOctalString      十进制转成8进制<br><strong>int –&gt; Integer</strong><br>Integer i4 = Integer.valueOf(10);<br><strong>String –&gt; Integer</strong><br>Integer i5 = Integer.valueOf(“10”);</p>
<p>Integet<br>int<br>String<br>三种类型互相转换<br>1.int–&gt;Integer</p>
<p>　Integer i1 =  Integer.valueOf(10);<br>2.Integer–&gt;int</p>
<p>　int i2 = i1.intValue();<br>3.String–&gt;Integr</p>
<p>　Integer i3 = Integer.valueOf(“10”);<br>4.Integer –&gt; String</p>
<p>　String s1 = i3.toString();<br>5.string –&gt; int</p>
<p>　int i4 = Integer.parseInt(“123”);<br>6.int –&gt; String</p>
<p>　String s5 = 10 + “”;</p>
<p>JDK5.0新特性：</p>
<p>　以下的特性适合JDK1.5版本之后的。包括1.5</p>
<p>　JDK1.4，包括1.4在内之前的所有版本不能使用以下特性</p>
<p>　自动装箱（auto_boxing）和自动拆箱（auto_unboxing）</p>
<p>深入自动装箱和自动拆箱</p>
<p>　1.自动装箱和自动拆箱是程序编译阶段的一个概念</p>
<p>　　和程序运行无关</p>
<p>　2.自动装箱和自动拆箱主要目的是为方便程序员编码</p>
<blockquote>
<p>Integer重写了equals方法</p>
<p>如果数据是在-128 <del>127之间，java中引入了一个“整型常量池”，在方法区中<br>该整型常量池只容乃-127</del>128的数据</p>
</blockquote>
<p>获取自1970/1/1 00/00/00/000到当前的毫秒数(时间戳)<br>System.currentTimeMillis();<br>获取系统当前时间对应的毫秒数<br>Date类<br>格式化日期<br>java.util.Date –&gt; String</p>
<p>　sdf.format()<br>解析日期<br>String –&gt; java.util.Date</p>
<p>　sdf.parse()<br>解析格式应该和字符串相同</p>
<p>日期格式<br>  y   年<br>  M   月<br>  d   日<br>  H   小时<br>  m   分<br>  s   秒<br>  S   毫秒</p>
<p>Date t1 = new Date(1000);</p>
<p>　1000是自1970-1-1 00:00:00 000的毫秒数</p>
<p>java.math.BigDecimal</p>
<p>　该类型精确度极高，适合做财务软件</p>
<p>　财务软件double类型精确度太低</p>
<p>生成随机数</p>
<p>　创建随机数生成器</p>
<p>　Random random = new Random();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day23/" class="post-title-link" itemprop="url">day23</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:31:09" itemprop="dateModified" datetime="2020-02-20T11:31:09+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk 8 之前 日期+时间 API的使用</p>
<p>java.util.Date类</p>
<p>　　|—-java.sql.Date类</p>
<p>1.java.util.Date类：</p>
<p>　　如何实例化：两个构造器</p>
<p>　　常用方法：toString() / getTime();</p>
<p> 2.java.sql.Date类：与数据表中的Date类型的变量对应。    </p>
<p>构造器一：获取系统当前时间对应的Date对象</p>
<p>Date date = new Date();</p>
<p>getTime()：返回当前日期对应的毫秒数：当前时间与1970-1-1 00：00：00直接的毫秒数</p>
<p>构造器二：获取毫秒数所对应的Date对象</p>
<p>Date date1 = new Date(1502768492941L);</p>
<p>SQl:</p>
<p>java.sql.Date date2 = new java.sql.Date(1502768492941L);</p>
<p>SimpleDateFormat</p>
<p>使用默认构造器:SimpleDateFormat sdf = new SimpleDateFormat();</p>
<p>格式化：String format(Date date):</p>
<p>　Date date = new Date();</p>
<p>　String dateStr = sdf.format(date);</p>
<p>解析： Date parse(String dateStr)</p>
<p>　Date date1 = sdf.parse(“17-8-15 下午2:18”);</p>
<p>　System.out.println(date1);</p>
<p>java.text.SimpleDateFormat类</p>
<p>　1.SimpleDateFormat的作用：</p>
<p>　　　格式化：日期—&gt;文本</p>
<p>　　　解析：格式化的逆过程，文本 —&gt;日期</p>
<p>　2.SimpleDateFormat实例化</p>
<p>　　使用带参数的构造器</p>
<p>　　　SimpleDateFormat sdf1 = new SimpleDateFormat(“EEE, d MMM yyyy HH:mm:ss Z”); 　　　</p>
<p>　　　SimpleDateFormat sdf1 = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);</p>
<p>　　格式化：</p>
<p>　　　String dateStr1 = sdf1.format(date);</p>
<p>　　　System.out.println(dateStr1);//2017-08-15 02:24:40</p>
<p>　　解析：</p>
<p>　　　Date date2 = sdf1.parse(“2017-08-15 02:24:40”);</p>
<p>　　　System.out.println(date2);</p>
<p>java.util.Calendar(日历)类的使用</p>
<p>　　1.实例化Calendar calendar = Calendar.getInstance();</p>
<p>　　2.get()</p>
<p>​        　int day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>​        　System.out.println(day);</p>
<p>　　3.set()</p>
<p>　　　calendar.set(Calendar.DAY_OF_MONTH, 20);　</p>
<p>　　　day =   calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　　System.out.println(day);</p>
<p>　　4.add()</p>
<p>　　　calendar.add(Calendar.DAY_OF_MONTH, -2);</p>
<p>　　　day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　　System.out.println(day);</p>
<p>日历 —&gt;日期</p>
<p>　　Date date = calendar.getTime();</p>
<p>　　System.out.println(date);</p>
<p>使用指定的Date对象，来设置calendar</p>
<p>　　Date date1 = new Date();</p>
<p>　　calendar.setTime(date1);</p>
<p>　　day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　System.out.println(day);</p>
<p>LocalDate / LocalTime / LocalDateTime     —–重要//理解为对Calendar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="comment">//now()</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime =   LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//of()</span></span><br><span class="line">LocalDate localDate2 = LocalDate.of(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">15</span>); </span><br><span class="line">System.out.println(localDate2);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">11</span>,<span class="number">23</span>); System.out.println(localDateTime2);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//getXxx():</span></span><br><span class="line">System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">System.out.println(localDateTime.getMonth());</span><br><span class="line">System.out.println(localDateTime.getMonthValue());</span><br><span class="line">System.out.println(localDateTime.getHour());</span><br><span class="line">System.out.println(localDateTime.getMinute());</span><br><span class="line"><span class="comment">//withXxx():体现了不可变性</span></span><br><span class="line">LocalDateTime localDateTime3=localDateTime.withDayOfMonth(<span class="number">20</span>); System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime3);</span><br><span class="line">LocalDateTime localDateTime4=localDateTime.withHour(<span class="number">12</span>); System.out.println(localDateTime4);</span><br><span class="line"><span class="comment">//plus()//minus()</span></span><br><span class="line">LocalDateTime localDateTime5 =localDateTime.plusDays(<span class="number">3</span>); System.out.println(localDateTime5);</span><br><span class="line">LocalDateTime localDateTime6 =localDateTime.minusMinutes(<span class="number">20</span>); </span><br><span class="line">System.out.println(localDateTime6);</span><br><span class="line"><span class="keyword">boolean</span> isBefore =localDateTime.isBefore(localDateTime6); </span><br><span class="line"> System.out.println(isBefore);<span class="comment">//false</span></span><br><span class="line"><span class="keyword">boolean</span> isAfter =localDateTime.isAfter(localDateTime6); System.out.println(isAfter);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//isLeapYear():</span></span><br><span class="line">System.out.println(localDate.isLeapYear());</span><br><span class="line">LocalDate localDate3 =localDate.minusYears(<span class="number">1</span>); </span><br><span class="line">System.out.println(localDate3.isLeapYear());</span><br></pre></td></tr></table></figure>





<p>Optional类使用的测试</p>
<p>　Optional:是一个封装了具体类型数据的容器。</p>
<p>　其中，具体的类型：通过Optional的泛型体现。</p>
<p>　具体类型的数据：通过Optional内部的T value体现</p>
<p>返回一个没有封装任何数据的Optional对象</p>
<p>　　Optional<Object> op = Optional.empty();０</Object></p>
<p>　　Optional<String> op1 = Optional.ofNullable(“beijing”);</String></p>
<p>isPresent():判断内部的数据是否存在</p>
<p>get():返回Optional对象内部封装的数据</p>
<p>of(T t):当t为null时，报异常。建议不用此方法</p>
<p>orElse(T t):如果调用对象包含值，返回该值，否则返回t</p>
<p>Integer类作为int的包装类，能存储的最大整型值为2^31−1， </p>
<p>BigInteger类的数值范围较Integer类、Long类的数值范围要大得多，可以支持任意精度的整数。</p>
<p>在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p>
<p>BigDecimal类支持任何精度的定点数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B67/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B67/" class="post-title-link" itemprop="url">进阶7</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:18:12" itemprop="dateModified" datetime="2020-02-20T11:18:12+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>迭代器，集合获取到迭代器之后，可以使用迭代器去遍历集合<br>List</p>
<p>　　存储元素的特点:有序可重复.有序，存进去是什么顺序，取出来时候还是这个顺序</p>
<p>　　ArrayList底层使用的是数组存储元素的，所以ArrayList适合查询，不适合频繁的增删元素</p>
<p>　　LinekList底层使用双向链表这种数据结构存储数据的,链表适合频繁的增删元素，不适合查询操作</p>
<p>　　Vector集合底层和ArrayList相同，但是Vector是线程安全的，效率较低<br>Set</p>
<p>　　存储元素的特点：无序不重复.存进去的时候是这样一个顺序，取出来的时候就不一定是这个顺序取出了</p>
<p>哈希表/散列表</p>
<p>Sorted 继承 Set</p>
<p>　存储元素的特点：无序不重复的。但是存储进去的元素可以按照元素的大小自动排序</p>
<p>Collection 常用方法</p>
<p>boolean add(Object element)   向集合中请添加元素<br>void clear()   清空集合<br>boolean isEmpty()  判断集合是否为空<br>int size() 获取集合中元素个数</p>
<p>Interator iterator() 获取集合所依赖的迭代器对象</p>
<p>　通过迭代器中方法完成集合的迭代（遍历）</p>
<p>　注意：这种方式是所有集合通用的遍历方式</p>
<p>迭代器面向接口编程<br>不需要关心底层集合的具体类型，所有集合依赖的迭代器都实现了java.util.Iterator接口<br>hasNext 判断是否还有更多的元素<br>next    将迭代器向下移动一位，并取出指向的元素</p>
<p>boolean contains(Object o) 集合中是否包含某个元素</p>
<p>　底层调用的是equals方法，如果equals返回true,就是包含<br>boolean remove(Object o)   删除集合中某个元素</p>
<p>存储在集合中的元素应该去重写equals方法</p>
<p>boolean remove(Object o)<br>remove和contains都需要集合中的元素重写equals方法，因为Object中的equals方法<br>比较内存地址，在现实的业务逻辑当中不能比较内存地址，该比较内容</p>
<p>深入remove方法</p>
<p>　1.迭代器的remove方法</p>
<p>　2.集合自身带的remove方法<br>推荐使用迭代器本身自带的方法删除元素</p>
<p>List集合存储元素特点：</p>
<p>　1.有序（List元素存储有下标）：存进去是这样的顺序，取出来还是按照这个顺序取出</p>
<p>　2.可重复</p>
<p>深入List集合<br> ArrayList集合底层是数组，数组下标是有序的<br> 所以在ArrayList集合有很多自己的特性<br> ArrayList集合底层默认初始化容量是10，扩大之后的容量是原容量的1.5倍<br> Vector集合底层默认初始化容量是10，扩大之后的容量是原容量的2倍</p>
<p> 如何优化ArrayList和Vector</p>
<p>　尽量减少扩容操作，因为扩容需要数组拷贝，数组拷贝很耗内存</p>
<p>　一般推荐在创建集合的时候指定初始化容量</p>
<p>Set集合：HashSet</p>
<ul>
<li><p>HashSet底层实际上是一个HashMap,HashMap底层采用了哈希表数据结构</p>
</li>
<li><p>哈希表又叫散列表，哈希表底层是一个数组，这个数组中每一个元素是一个单向链表<br>每个单向链表都有独一无二的hash值,代表数组的下标.在某个单向链表的每一个节点<br>上的hash值是相等的.hash值实际上是key调用hashCode方法，再通过“hash function”</p>
<p>转换成的值</p>
</li>
<li><p>如何向哈希表中添加元素：</p>
<p>　　 先调用被存储的key的hashCode方法，经过某个算法得出hash值，如果在这个哈希表中</p>
<pre><code>  　　不存在这个hash值，则直接添加元素.如果该hash值已经存在，继续调用key之间的equals</code></pre></li>
</ul>
<p>　　　　方法，如果equals返回false,则将该元素添加。如果equals方法返回true,则放弃添加该元素</p>
<ul>
<li>HashSet其实是HashMap中的key部分。HashSet有什么特点，HashMap中的key应该具有相同的特点<br>   5.HashMap和HashSet初始化容量都是16，默认加载因子是0.75</li>
</ul>
<p>关于往Set集合中存储的元素，该元素的hashCode方法和equals方法<br>HashMap中有一个put方法，put(key,value) key是无序的不可重复的<br>结论:存储在HashSet集合或者HashMap集合key部分的元素，需要同时重写hashCode1+equals</p>
<p>java.util.Set</p>
<p>　java.util.SortedSet  无序不重复，但是存进去的元素可以按照元素大小自动排序</p>
<p>　　java.util.TreeSet</p>
<p>SortedSet存储元素为什么可以自动排序？   (equals返回false,才会比较）</p>
<p>　 因为被存储的元素实现了Comparable接口，</p>
<p>　SUN编写TreeSet集合在添加元素的时候，会</p>
<p>　调用compareTo方法完成比较</p>
<p>让SortedSet集合做到排序还有另一种方式java..util.Comparator<br>单独编写一个比较器</p>
<p>map集合中的常用方法<br>  void clear() 清空map<br>  boolean containsKey(Object key)    判断集合中是否包含这样的key<br>  boolean containsValue(Object value)  判断集合中是否包含这样的value</p>
<p>  Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() </p>
<p>　　返回此映射中包含的映射关系的 Set 视图。 </p>
<p> V get(Object key)   通过key获取value<br> boolean isEmpty()   判断该集合是否为空<br> Set<K> keySet()     获取map中所有key<br> V put(K key, V value)  向集合中添加键值对<br> V remove(Object key)   通过key删除元素<br> int size()             获取map中键值对的个数<br> Collection<V> values   获取map集合中所有value<br> Set keySet() 获取所有的key<br> set entrySet()  Map转换成Set</V></K></p>
<p>注意：存储在Map集合key部分的元素需要同时重写hashCode+equals</p>
<p>　　HashMap和HashSet初始化容量都是16，默认加载因子是0.75</p>
<p>Map中如果key重复了,value采用的是“覆盖”</p>
<p>HashMap和HashSet初始化容量都是16，默认加载因子是0.75<br>Hashtable默认初始化容量是11，默认加载因子是0.75<br>java.util.Properties 也是由key和value组成，但是key和value都是字符串类型</p>
<p>SortedMap中的key特点：无需不可重复，但是存进去的元素可以按照大小自动排序<br>如果想自动排序：key部分的元素需要，1.实现comparable接口 2.单独写一个比较器</p>
<p>关于集合工具类 java.util.Collections<br>java.util.Collecition 集合接口</p>
<p>　　Collections工具类可以对List集合中的元素排序，但是集合中的元素必须是“可比较的”，实现comparable接口</p>
<p>关于JDK5.0新特性的新特性：泛型（编译期概念）</p>
<p>　1.为什么引入泛型？</p>
<p>　　1.可以统一集合中的数据类型</p>
<p>　　2.可以减少强制类型转换</p>
<p>　2.泛型语法如何实现？</p>
<p>　　泛型是一个编译阶段的语法</p>
<p>　　在编译阶段统一集合中的类型</p>
<p>　3.泛型的有点和缺点？</p>
<p>　　优点：同一类型，减少强制转换</p>
<p>　　缺点：类型太统一了</p>
<p>自定义泛型</p>
<p>JDK5.0新特性：</p>
<p>　关于增强for循环</p>
<p>　语法：</p>
<p>　　for(类型 变量：数组名/集合名){}</p>
<p>　集合要想使用增强for循环这种语法，集合需要使用泛型</p>
<p>　如果集合不使用泛型，该集合在使用增强for循环的时候应该使用Object类型定义</p>
<p>关于增强for的缺点:没有下标</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B68/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B68/" class="post-title-link" itemprop="url">进阶８</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:43:04" itemprop="dateModified" datetime="2020-02-12T15:43:04+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java.io.*;</p>
<p>FileInputStream<br>FileOutputStream<br>FileReader<br>FileWriter</p>
<p>BufferedReader    带有缓冲区的字符输入流<br>BufferedWriter     带有缓冲区的字符输出流</p>
<p>字节<br>BufferedInputStream<br>BufferedOutputStream</p>
<p>DateInputStream<br>DateOutputStream</p>
<p>ObjectInputStream<br>ObjectOutputStream</p>
<p>转换流（字节流转换成字符流）<br>InputStreamReader<br>OutputStreamWriter</p>
<p>PrintWriter<br>PrintStream  标椎输出流，默认输出到控制台</p>
<p>java语言中的流分为:4大家族(InputStream,OutputStream,Reader,Writer)</p>
<p>java.io.InputStream</p>
<p>　java.io.FileInputStream  文件字节输入流</p>
<p>　按照字节方式读取文件</p>
<p>int read()<br>int read(byte[] bytes)<br>available    流中估计的字节数<br>skip(int n)  跳过多少个字节</p>
<p>java.io.OutputStream</p>
<p>　java.io.FileOutputStream  文件字节输出流</p>
<p>　将计算机内存中的数据写入硬盘文件中</p>
<p>java.io.Reader;</p>
<p>　java.io.InputStremReader; 转换流</p>
<p>　　java.io.FileReader; 文件字符输出流<br>skip</p>
<p>java.io.Writer;</p>
<p> java.io.ObjectOutputStream 序列化JAVA对象到硬盘(Serial)</p>
<p>　　java.io.ObjectInputStream 将硬盘中的数据“反序列化”到JVM内存中（DeSerial）</p>
<p>Compile 编译(java–&gt;class)<br>Decompile 反编译(class–&gt;java)</p>
<p>标识接口的作用:起到标识的作用</p>
<p>　 JVM如果看到该对象实现某个标识接口,会对它特殊待遇</p>
<p>java.io.OutputStreamWriter; 转换流</p>
<p>　java.io.FileWriter;  文件字符输出流</p>
<p>java.io.DateOutputStream 数据字节输出流</p>
<p>　可以将内存中的“int i = 10”写入到硬盘文件中</p>
<p>　写进去的不是字符串,写进去的是二进制数据,带类型</p>
<p>注意:要使用该流数据读取数据,必须提前知道该文件中数据存储格式,顺序</p>
<p>　　读的顺序必须和写入的顺序一致</p>
<p>根据流出现的位置,流又可以分为:包装流或者处理流和节点流</p>
<p>java.io.ObjectOutputStream 序列化JAVA对象到硬盘(Serial)<br>java.io.ObjectInputStream 将硬盘中的数据“反序列化”到JVM内存中（DeSerial）</p>
<p>Compile 编译(java–&gt;class)<br>Decompile 反编译(class–&gt;java</p>
<p>标识接口的作用:起到标识的作用<br>   JVM如果看到该对象实现某个标识接口,会对它特殊待遇</p>
<p>Serializable 可序列化<br>transient 不参加序列化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B62/" class="post-title-link" itemprop="url">进阶2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:12:20" itemprop="dateModified" datetime="2020-02-12T15:12:20+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于java语言中的数据类型</p>
<p>　byte   1byte(8bit)  -128-127</p>
<p>　short  2byte</p>
<p>　int    4byte</p>
<p>　long   8byte<br>整数有3中表现形式:</p>
<p>　十进制</p>
<p>　八进制　 以0开始</p>
<p>　十六进制 以0x开始</p>
<p>在java中基本类型可以相互转换,boolean类型比较特殊不可以转换成其他类型</p>
<p>转换分为自动类型提升和强制类型转换：</p>
<p>　自动类型提升:容量小的类型会默认转换为容量大的类型</p>
<p>　byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>　char</p>
<p>byte,short,char之间计算不会相互转换,首先先转成int</p>
<p>　强制类型转换：</p>
<p>　　将容量大的类型转换成容量小的类型,需要进行强制转换</p>
<p>　　注意：只要不超出范围可以将整型值直接赋值给byte,short,char</p>
<p>在多种类型混合运算过程中,首先将所有数据转换成容量大的那种,再运算</p>
<p>关于java中的布尔类型</p>
<p>　1.boolean类型的数据只有两个值:true/false，没有1和0</p>
<p>　2.boolean类型的数据主要用在逻辑运算和条件控制语句中<br>java程序分为编译期和运行期</p>
<p>关系运算符</p>
<p>＞<br>＞=    大等于<br>&lt;     小于<br>&lt;=    小等于<br>==    判断是否相等(基本数据类型)<br>!=    不等于<br>关系运算符的运算结果一定是boolean类型</p>
<p>布尔运算符(逻辑运算符)</p>
<p>　&amp;     逻辑与</p>
<p>　|     逻辑或</p>
<p>　!     逻辑非</p>
<p>　^     逻辑异或</p>
<p>　&amp;&amp;    短路与</p>
<p>　||    短路或<br>短路：后边那个表达式不执行</p>
<p>　什么时候发生短路与? 第一个算子结果是false的时候</p>
<p>　什么时候发生短路或？第一个算子结果是true的时候<br>布尔运算符两边的(算子)必须是布尔类型,整个表达式的运算结果也是一个布尔类型</p>
<p>关于赋值运算符</p>
<p>　基本的赋值运算符</p>
<p>　=</p>
<p>　扩展的赋值运算符</p>
<p>　+=    追加</p>
<p>　-=</p>
<p>　*=</p>
<p>　/=</p>
<p>　%=<br>基本运算符和扩展运算符的区别？　</p>
<p>　扩展运算符不会改变变量本身的数据类型</p>
<p>关于字符串连接运算符</p>
<p>　＋运算符可以：</p>
<p>　　1.做加法运算(+两边只要都是数字类型,一定是加法运算)</p>
<p>　　2.字符串连接(+两边任意一端只要是字符串类型,则一定是字符串连接)</p>
<p>条件运算符(三目运算符)</p>
<p>　？：</p>
<p>　语法：</p>
<p>　　boolean表达式?表达式1:表达式2</p>
<p>　　boolean表示式的结果是true，则整个表达式的结果就是表达式1的结果,相反则是表达式2的结果</p>
<p>关于条件控制语句:流程控制语句if…else<br>    1.语法<br>    第一种结构：<br>        if(boolean表达式){<br>        java语句;<br>    }<br>    第二种结构:<br>    if(boolean表达式){<br>        java语句;<br>    }else{<br>        java语句;<br>    }<br>    第三种结构:<br>    if（boolean表达式）{<br>        java语句;<br>    }else if(boolean表达式){<br>        java语句；<br>    }else if(boolean表达式){<br>        java语句；<br>    }<br>    第四种结构:<br>    if（boolean表达式）{<br>        java语句;<br>    }else if(boolean表达式){<br>        java语句；<br>    }else if(boolean表达式){<br>        java语句；<br>    }else{<br>    }<br>注意：在if语句中只要有一个分支执行,则整个if语句结束</p>
<p>　　上面的结构2.4可以保证一定会有一个分支语句执行,因为他们都有else语句。<br>！！ else 有隐藏条件</p>
<p>关于switch语句:<br>    1.语法:<br>        switch(int类型){<br>            case int类型:<br>            java语句；<br>            java语句；<br>            break;</p>
<p>​           case int类型:<br>           java语句；<br>​           java语句；<br>​           break;</p>
<p>​           case int类型:<br>​           java语句；<br>​           java语句；<br>​           break;</p>
<p>​            default:<br>​            java语句；<br>​    }</p>
<p>注意：break；语句可以没有，default也可以没有<br>      break语句如果没有，则发生case穿透现象<br>      switch后面的括号可以填写byte/short/char类型,因为可以自动转换<br>      jdk7.0可以是String类型<br>      case可以合并        </p>
<p>for 循环:<br>    语法：<br>    for(表达式1;表达式2;表达式3){<br>        java语句<br>    }<br>    表达式1是初始化表达式,最先执行,只执行一次<br>    表达式2必须是boolean类型的表达式</p>
<p>for循环开始执行,先执行表达式1,并只执行一次,进而判断表达式2的结果,如果是true<br>则执行java语句,再执行表达式3,然后再判断表达式2的结果，知道表达式2的结果是false<br>则for循环结束。</p>
<p>关于while循环<br>    语法<br>        while(boolean表达式）{<br>            java语句；<br>        }<br>该循环的执行次数:0-N</p>
<p>关于do…while…<br>    语法：<br>        do{<br>            java语句；<br>        }while(boolean表达式)；</p>
<p>该循环的执行次数:1-N</p>
<p>break语句：</p>
<ul>
<li><p>可以用在switch语句中,结束分支语句</p>
</li>
<li><p>break；语句可以出现在循环当中,默认情况下结束离它最近的一个循环<br>continue语句:可以用来结束当前一次循环,直接进入下一次循环继续执行</p>
<p>通过break可以指定结束某个循环(标签)</p>
</li>
</ul>
<p>定义方法的语法：    </p>
<p>　[方法的修饰列表] 方法的返回值类型 方法名(方法的形参列表){</p>
<p>　　java语句；</p>
<p>　}</p>
<p>1.[方法的修饰列表]是可选项 。暂时携程public static<br>2.方法的返回值类型,可以是java语言中的任何一种数据类型(基本数据类型和引用数据类型)<br>3.如果该方法执行结束之后,并没有任何返回值,那抹定义方法的时候,返回值类型写:void<br>4.方法名只要是合法的标识符即可<br>5.方法的形参参数列表,可以有参数,也可以没有参数,如果有多个参数的话使用”逗号”分开<br>6.如果一个方法的返回值的类型不是void，那抹在方法体中必须使用return语句来返回数据</p>
<p>方法的形式参数列表中起决定性作用的是参数的类型<br>参数的名字（局部变量的名字）是随意的只要是合法的标识符即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/%E8%BF%9B%E9%98%B69/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/%E8%BF%9B%E9%98%B69/" class="post-title-link" itemprop="url">进阶9</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:42:04" itemprop="dateModified" datetime="2020-02-12T15:42:04+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>File<br>   boolean canExecute()<br>          测试应用程序是否可以执行此抽象路径名表示的文件。<br> boolean canRead()<br>          测试应用程序是否可以读取此抽象路径名表示的文件。<br> boolean canWrite()<br>          测试应用程序是否可以修改此抽象路径名表示的文件。<br> int compareTo(File pathname)<br>          按字母顺序比较两个抽象路径名。<br> boolean createNewFile()<br>          当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。<br>static File createTempFile(String prefix, String suffix)<br>          在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。<br>static File createTempFile(String prefix, String suffix, File directory)<br>           在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。<br> boolean delete()<br>          删除此抽象路径名表示的文件或目录。<br> void deleteOnExit()<br>          在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。<br> boolean equals(Object obj)<br>          测试此抽象路径名与给定对象是否相等。<br> boolean exists()<br>          测试此抽象路径名表示的文件或目录是否存在。<br> File getAbsoluteFile()<br>          返回此抽象路径名的绝对路径名形式。<br> String getAbsolutePath()<br>          返回此抽象路径名的绝对路径名字符串。<br> File getCanonicalFile()<br>          返回此抽象路径名的规范形式。<br> String getCanonicalPath()<br>          返回此抽象路径名的规范路径名字符串。<br> long getFreeSpace()<br>          返回此抽象路径名指定的分区中未分配的字节数。<br> String getName()<br>          返回由此抽象路径名表示的文件或目录的名称。<br> String getParent()<br>          返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。<br> File getParentFile()<br>          返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。<br> String getPath()<br>          将此抽象路径名转换为一个路径名字符串。<br> long getTotalSpace()<br>          返回此抽象路径名指定的分区大小。<br> long getUsableSpace()<br>          返回此抽象路径名指定的分区上可用于此虚拟机的字节数。<br> int hashCode()<br>          计算此抽象路径名的哈希码。<br> boolean isAbsolute()<br>          测试此抽象路径名是否为绝对路径名。<br> boolean isDirectory()<br>          测试此抽象路径名表示的文件是否是一个目录。<br> boolean isFile()<br>          测试此抽象路径名表示的文件是否是一个标准文件。<br> boolean isHidden()<br>          测试此抽象路径名指定的文件是否是一个隐藏文件。<br> long lastModified()<br>          返回此抽象路径名表示的文件最后一次被修改的时间。<br> long length()<br>          返回由此抽象路径名表示的文件的长度。<br> String[] list()<br>          返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。<br> String[] list(FilenameFilter filter)<br>          返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。<br> File[] listFiles()<br>          返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。<br> File[] listFiles(FileFilter filter)<br>          返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。<br> File[] listFiles(FilenameFilter filter)<br>          返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。<br>static File[] listRoots()<br>          列出可用的文件系统根。<br> boolean mkdir()<br>          创建此抽象路径名指定的目录。<br> boolean mkdirs()<br>          创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。<br> boolean renameTo(File dest)<br>          重新命名此抽象路径名表示的文件。<br> boolean setExecutable(boolean executable)<br>          设置此抽象路径名所有者执行权限的一个便捷方法。<br> boolean setExecutable(boolean executable, boolean ownerOnly)<br>          设置此抽象路径名的所有者或所有用户的执行权限。<br> boolean setLastModified(long time)<br>          设置此抽象路径名指定的文件或目录的最后一次修改时间。<br> boolean setReadable(boolean readable)<br>          设置此抽象路径名所有者读权限的一个便捷方法。<br> boolean setReadable(boolean readable, boolean ownerOnly)<br>          设置此抽象路径名的所有者或所有用户的读权限。<br> boolean setReadOnly()<br>          标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。<br> boolean setWritable(boolean writable)<br>          设置此抽象路径名所有者写权限的一个便捷方法。<br> boolean setWritable(boolean writable, boolean ownerOnly)<br>          设置此抽象路径名的所有者或所有用户的写权限。<br> String toString()<br>          返回此抽象路径名的路径名字符串。<br> URI toURI()<br>          构造一个表示此抽象路径名的 file: URI。<br> URL toURL()<br>          已过时。 此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。 </p>
<p>多进程：提高CPU的使用率</p>
<p>　进程和进程之间的内存是独立的<br>多线程：线程是进程中的一个执行场景</p>
<p>　提高应用程序的使用率</p>
<p>　线程和线程共享“堆内存和方法区内存”，栈内存是独立的，一个线程一个栈</p>
<p>创建线程的2种方式<br>继承Thread<br>实现Runnable接口</p>
<p>线程优先级高的获取的cpu的时间片相对多一些</p>
<p>　优先级1-10</p>
<p>　最低1</p>
<p>　最高10</p>
<p>　默认5</p>
<p>setPriority()</p>
<p>getPriority();</p>
<p>MAX_PRIORITY  10<br>NORM_PRIORITY 5<br>MIN_PRIORITY  1</p>
<p>Thread.sleep(毫秒);</p>
<p>　2.sleep()方法是一个静态方法</p>
<p>　3.该方法的作用:阻塞当前线程,腾出cpu,让给其他线程</p>
<p>interrupt()  中断休眠,利用的是异常处理机制<br>join 线程合并</p>
<p>异步线程模型</p>
<p>　线程之间不必等待<br>同步线程模型</p>
<p>　线程之间排队</p>
<p>什么时候使用同步呢？为什么要引入线程同步呢？</p>
<p>　1.为了数据的安全.尽管应用程序的使用率低,但是为了保证书是安全的,必须加入线程同步机制</p>
<p>　  线程同步机制是程序变成了（等同）单线程</p>
<p>　2.什么条件下使用线程同步？</p>
<p>　   第一: 必须是多线程环境</p>
<p>　   第二：多线程环境共享同一个数据</p>
<p>　   第三：共享的数据涉及到修改操作</p>
<p>synchronized(){} 同步代码块</p>
<p> 守护线程</p>
<p>　其他所有的用户线程结束,则守护线程退出</p>
<p>　守护线程一般都是无限执行的</p>
<p>　setDaemon</p>
<p>关于定时器的应用</p>
<p>　　作用:每隔一段固定的时间执行一段代码</p>
<p>以下是sun提供的反射机制中的类<br>    java.lang.Class;<br>    java.lang.reflect.Constructor;<br>    java.lang.reflect.Field;<br>    java.lang.Method;<br>    java.lang.Modifier;</p>
<p>​    private User{</p>
<p>​    }</p>
<p>反射机制的作用:</p>
<p>　　1.反编译: .class -&gt; .java</p>
<p>　　2.通过反射机制访问java类的属性,方法,构造方法等. </p>
<p>第一种方式:</p>
<p>　　将类加载到JVM中</p>
<p>　　Class c1 = Class.forName(“User”);    // c1引用保存地址指向堆中的对象,该对象代表的是User整个类<br>第二种方式:</p>
<p>　　Class c2 = User.class;<br>第三种方式：</p>
<p>　　User u = new User();</p>
<p>　　Class sc3 = u.getClass();</p>
<p>newInstance相当于调用了无参构造器</p>
<p>关于java中的可变长参数</p>
<p>　如果有精确匹配的方法，则调用该方法，不会再去执行可变长形参的那个方法</p>
<p>　可变长形参等同看做数组</p>
<p>　可变长参数只能出现一次,并且只能出现在参数列表的最后一个位置上</p>
<p>IO+Properties</p>
<p>配置文件（属性文件）<br>java规范要求属性文件以“.properties”<br>配置文件的作用使程序更灵活<br>注意：一般程序中可变的东西不要写死，推荐写到配置文件中 运行同样的程序得到不同的结果</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day22/" class="post-title-link" itemprop="url">day22</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:35:08" itemprop="dateModified" datetime="2020-02-20T11:35:08+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、继承Thread的方式</p>
<p>　　1.提供一个继承于Thread类的子类</p>
<p>　　2.重写Thread类的run():将创建的线程要执行的操作，声明在run()中。</p>
<p>　　3.实例化Thread子类</p>
<p>　　4.调用子类对象的start() </p>
<p>Thread类的常用方法的测试</p>
<p> 　　1.run():Thread的子类一定要重写的方法。将此分线程要执行的操作，声明在run()中</p>
<p>　 　2.start():要想启动一个分线程，就需要调用start():①启动线程②调用线程的run()</p>
<p>　 　3.currentThread():静态方法，获取当前的线程</p>
<p>　 　4.getName():获取当前线程的名字</p>
<p>　 　5.setName(String name)：设置当前线程的名字</p>
<p>　 　6.yield():当前线程调用此方法，释放CPU的执行权</p>
<p>　 　7.join():在线程a中调用线程b的join()方法:只用当线程b执行结束以后，线程a结束阻塞状态，继续执行。</p>
<p>　　 8.sleep(long millitimes):让当前的线程睡眠millitimes毫秒</p>
<p>　 　9.isAlive():判断当前线程是否存活 </p>
<p>　　10.线程的优先级：</p>
<p>　　　　 MAX_PRIORITY：10 </p>
<p>　　　　NORM_PRIORITY：5 —默认优先级</p>
<p>　　　　MIN_PRIORITY：1</p>
<p>​    　 设置优先级：setPriority(int priority); </p>
<p>​    　 获取优先级：getPriority()；</p>
<blockquote>
<p>设置优先级以后，对高优先级，使用优先调度的抢占式策略，抢占低优先级的执行。但是并不意味着高优    先级的线程一定先于低优先级的线程执行，而是从概率上来讲，概率更大而已。</p>
</blockquote>
<p> 线程通信：wait() / notify() / notifyAll()  —-&gt;java.lang.Object类中定义的方法</p>
<h4 id="一：继承Thread的方式"><a href="#一：继承Thread的方式" class="headerlink" title="一：继承Thread的方式"></a>一：继承Thread的方式</h4><p>　　　1.提供一个继承Thread类的子类 </p>
<p>　　　2.重写Thread类run():将创建的线程要执行的操作,声明在run()中 </p>
<p>　　　3.实例化Thread子类</p>
<p>　　　4.调用子类对象的start()方法</p>
<h4 id="创建多线程的方式二"><a href="#创建多线程的方式二" class="headerlink" title="创建多线程的方式二:"></a>创建多线程的方式二:</h4><p>　　　1.创建一个实现Runnable接口的类</p>
<p>　　　2.实现Runnable的run()</p>
<p>　　　3.创建当前实现类的对象</p>
<p>　　　4.将此对象作为参数传递到Thread类的构造器中,创建Thread类的对象</p>
<p>　　　5.通过Thread类的对象调用其start()</p>
<p>对比继承Thread类和实现Runnable接口的方式</p>
<p>　　　1.联系:public class Thread implements Runnable</p>
<p>　　　2.相同点:启动线程,使用的是同一个start()方法</p>
<p>　　　3.对比:实现Runnable接口要好一些. </p>
<p>　原因：①不影响类的继承,因为类是单继承的   </p>
<p>　　　　②针对于有共享数据的操作,更适合使用Runnable的方式 ,换句话说,实现Runnable接口的方式,实现了代                    码和数据的分离</p>
<p>　　　4.面试题:创建多线程有几种方法?     继承Thread类,实现Runnable接口,实现Callable接口,使用线程池</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张。—–使用实现的方式</p>
<p>　　1.问题：出现了重票和错票</p>
<p>　　2.问题出现的原因：一个窗口在没有售完票的情况下，其他的窗口参与进来，操作ticket，导致ticket输出的错            误。</p>
<p>　　3.解决的方案：当某一个窗口完全操作完ticket以后，其他窗口应该才被允许进来，继续操作ticket。</p>
<p>　　4.java如何实现的？同步机制：①同步代码块    ②同步方法 </p>
<p>　　　4.1 同步代码块：</p>
<p>​                 synchronized(同步监视器){</p>
<p>​                       //需要被同步的代码</p>
<p>​               }</p>
<p>　　　说明：需要被同步的代码：即为操作共享数据的代码</p>
<p>　　　　　　共享数据：多个线程共同操作的数据。比如：ticket</p>
<p>　　　　　　同步监视器：俗称：锁。 可以由任何一个类的对象充当。 要求：保证多个线程共用同一把锁！</p>
<p>　　　4.2 同步方法：将操作共享数据的方法，声明为同步的。此方法即为同步方法。</p>
<p>　　　　　使用同步方法解决实现方式的线程安全问题。</p>
<p>　　　　　1.默认的同步方法（非静态的）的锁是：当前对象，也就是this.</p>
<p>　　　　　2.默认的同步方法（静态的）的锁是：当前类本身.</p>
<p>　　　　　　使用同步方法解决继承方式的线程安全问题：</p>
<p>　　　　　注意：继承的方式中，要慎用同步方法。</p>
<p>​        5.好处：线程的同步机制，解决了线程的安全问题。</p>
<p>​        6.劣势：在操作共享数据过程中，是单线程的。</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张     —–使用实现的方式</p>
<p>　　解决线程安全问题的方式三：ReentrantLock</p>
<p>　　存在线程的安全问题，使用Lock的方式解决线程安全问题。</p>
<p>面试题：同步的方式和Lock的方式，解决线程安全方面的异同？</p>
<p>　　同：解决了线程安全问题</p>
<p>　　异：同步的方式：同步监视器在线程执行完操作共享数据的代码以后，自动释放</p>
<blockquote>
<p> Lock的方式：需要显式的调用unlock()方法之后，才能保证其他线程操作共享数据。 </p>
</blockquote>
<p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，是我们开发中需要规避的！</p>
<p>线程的通信：</p>
<ul>
<li><p>wait():一个线程在执行过程中，一旦调用此方法，则此线程进入阻塞状态，等待其他线程来唤醒自己。    </p>
</li>
<li><p>notify():一个线程在执行过程中，一旦调用此方法，则会唤醒被wait()的一个线程。高优先级的要优先被唤醒。</p>
</li>
<li><p>notifyAll():一个线程在执行过程中，一旦调用此方法，则会唤醒所有被wait()的线程。</p>
</li>
</ul>
<p>　　　例题：使用两个线程打印 1-100. 线程1, 线程2 交替打印</p>
<p>注意点：1.此三个方法必须使用在同步中。</p>
<p>　　　　2.此三个方法的调用者是同步监视器！否则，如果三个方法的调用者不是同步监视器，报异常。</p>
<p>　　　　3.此三个方法定义在Object类</p>
<p>面试题：sleep() 和  wait() 的异同？</p>
<p>　　1.方法声明在哪？ Thread:sleep()   Object:wait()</p>
<p>　　2.共同点：使得当前线程进入阻塞状态</p>
<p>　　3.使用的范围要求：sleep()使用没有情境的要求；wait()必须使用在同步代码块或同步方法中</p>
<p>　　4.都使用在同步当中的话：wait()需要唤醒：notify()/notifyAll();  sleep():不会释放锁；wait()会释放锁 </p>
<p> String:字符串</p>
<p>　　　1.字符串声明的数据，会存储在字符串常量池中。第一次声明时，需要创建相应的字符串。之后，如果声明的变量，其值与之前存在的字符串内容相同，则直接引用现成的字符串。</p>
<p>　　　2.面试题：String s3 = new String(“javaEE”);创建的对象，在内存中生成了几个对象？</p>
<p><strong>String:代表着不可变的字符序列。</strong></p>
<p>　　　1.String类的声明public final class String implements java.io.Serializable, Comparable<String>, 　　　　CharSequence</String></p>
<p>　　　　　①String声明为final，不可被继承。</p>
<p>　　　　　②实现Serializable：表明String可序列化。浏览器/客户端&lt;—&gt;服务器端     进程1&lt;—-&gt;进程2    　　　　　　“{name=Tom,age=12}”    JSON:本质就是String</p>
<p>　　　　　③String重写了hashCode()/equals():常常将Map的key声明为String型。</p>
<p>　　　　　④实现Comparable接口：String可以比较大小。</p>
<p>　　　　　⑤实现CharSequence接口：String的底层声明了char[] value数组。</p>
<p>　　　2.如何理解String的不可变性：</p>
<p>　　　　　①向现有的字符串后添加新的字符串，必须声明新的字符串空间</p>
<p>　　　　　②将现有的字符串替换为新的字符串，必须声明新的字符串空</p>
<p>　　　　　③只替换现有字符串中的指定某个字符，也必须声明新的字符串空间</p>
<p>String类与其它结构的转换：</p>
<p>　　　1.String 与包装类、基本数据类型变量间的转换    </p>
<p>　　　　String–&gt;包装类、基本数据类型:调用包装类Xxx的parseXxx(String s)方法</p>
<p>　　　　包装类、基本数据类型 –&gt;String:调用String的valueOf(xxx xxx); </p>
<p>　　　2.String 与 字节数组间的转换   </p>
<p>　　　　String –&gt; 字节数组:调用String类的getBytes()</p>
<p>　　　　字节数组–&gt;String:new String(byte[] buffer,startIndex,length)</p>
<p>　　　3.String 与 字符数组间的转换</p>
<p>　　　　String –&gt; 字符数组：调用String类的toCharArray()</p>
<p>　　　　字符数组 –&gt;String:new String(char[] cbuf,startIndex,length)    </p>
<p>​         </p>
<ul>
<li><p>public String substring(int startpoint):返回当前字符串中从startPoint位置开始，到末尾的子字符串。  </p>
</li>
<li><p>public String substring(int start,int end):返回当前字符串中从startPoint位置开始，到end结束的左闭右开区间的子字符串。</p>
</li>
<li><p>pubic String replace(char oldChar,char newChar):将字符串中指定的所有oldChar替换为newChar.</p>
</li>
<li><p>public String replaceAll(String old,String new):将字符串中指定的所有old替换为new.</p>
</li>
<li><p>public String trim():去除字符串首尾的空格</p>
</li>
<li><p>public String concat(String str):连接两个字符串</p>
</li>
<li><p>public boolean contains(CharSequence s)：判断当前字符串中是否包含s.</p>
</li>
<li><p>public String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。</p>
</li>
</ul>
<ul>
<li><p>public int length():返回当前字符串的长度</p>
</li>
<li><p>public char charAt(int index)：获取指定索引位置的字符</p>
</li>
<li><p>public boolean equals(Object anObject)：比较两个字符串内容是否相等。</p>
</li>
<li><p>public int compareTo(String anotherString):比较两个字符串的大小</p>
</li>
<li><p>public int indexOf(String s):返回s在当前字符串中首次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int indexOf(String s ,int startpoint):</p>
</li>
<li><p>public int lastIndexOf(String s):返回s在当前字符串中末次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int lastIndexOf(String s ,int startpoint):</p>
</li>
<li><p>public boolean startsWith(String prefix)：判断当前的字符串是否以指定的prefix字符串开始的</p>
</li>
<li><p>public boolean endsWith(String suffix)：判断当前的字符串是否以指定的suffix字符串结束的</p>
</li>
<li><p>public boolean regionMatches(int firstStart,String other,int otherStart ,int length)   ？</p>
</li>
</ul>
<p>面试题：</p>
<p>　　String:不可变的字符序列；底层使用char[]存储</p>
<p>　　StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储  </p>
<p>　　StringBuilder:可变的字符序列；线程不安全的，效率高，(jdk 5.0新增)；底层使用char[]存储</p>
<p>类比：String —&gt;数组； StringBuffer —&gt;Vector   StringBuilder —&gt;ArrayList</p>
<p>　　　ArrayList list = new ArrayList();</p>
<p>　　　list.add(123);//new Object[10];</p>
<p>　　　….</p>
<p>　　　扩容:1.5倍的方式扩容。</p>
<p>　　　这里：</p>
<p>　　　　String str = new String();//new char[0];</p>
<p>　　　　str.length();</p>
<p>　　　　String str1 = new String(“abc”);//new char[]{‘a’,’b’,’c’};</p>
<p>　　　对比：</p>
<p>　　　　StringBuffer s1 = new StringBuffer();//char[] value = new char[16]</p>
<p>　　　　StringBuffer s2 = new StringBuffer(10);//char[] value = new char[10]</p>
<p>　　　　s1.append(“abc”);//value[0] = ‘a’,value[1] = ‘b’,value[2] = ‘c’;</p>
<p>　　　　　… </p>
<p>　　　　　　  每次添加时，都需要判断底层的char[]是否能够盛装下新要添加的字符串。</p>
<p>　　　　　　 如果不能盛装下，需要扩容。默认扩容为原来的2倍 + 2.   </p>
<p>　　　 启示：StringBuffer s1 = new StringBuffer(int capacity);开发中建议使用此构造器。</p>
<p>StringBuffer中的方法：</p>
<ul>
<li><p>StringBuffer append(String s),</p>
</li>
<li><p>StringBuffer append(int n) ,</p>
</li>
<li><p>StringBuffer append(Object o) ,</p>
</li>
<li><p>StringBuffer append(char n)，</p>
</li>
<li><p>StringBuffer append(long n),</p>
</li>
<li><p>StringBuffer append(boolean n),</p>
</li>
<li><p>StringBuffer insert(int index, String str)</p>
</li>
<li><p>public StringBuffer reverse()</p>
</li>
<li><p>StringBuffer delete(int startIndex, int endIndex):删除当前可变字符串中从startIndex到endIndex结束的左闭右开区间的数据。</p>
</li>
<li><p>public char charAt(int n )</p>
</li>
<li><p>public void setCharAt(int n ,char ch)</p>
</li>
<li><p>StringBuffer replace( int startIndex ,int endIndex, String str)</p>
</li>
<li><p>public int indexOf(String str)</p>
</li>
<li><p>public String substring(int start,int end)</p>
</li>
<li><p>public int length()</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　增：append(Xxx xxx)</p>
<p>　　删：delete(int startIndex, int endIndex</p>
<p>　　改：setCharAt(int n ,char ch) / replace( int startIndex ,int endIndex, String str)</p>
<p>　　查：charAt(int n)</p>
<p>　　插：insert(int index, String str)</p>
<p>　　长度：length()</p>
<p>　　遍历：使用for + charAt()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day12/" class="post-title-link" itemprop="url">day12</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:27:11" itemprop="dateModified" datetime="2020-02-12T14:27:11+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>786</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>equals 方法的使用</p>
<p>​     1.java.lang.Object 类中的equals()方法的定义:</p>
<p>​               public boolean equals(Object obj){  </p>
<p>​                           return(this == obj);</p>
<p>​             }  </p>
<p>​       说明:Object 类中equals()比较两个对象的引用地址是否相同，（或:比较两个引用是否指向同一个对象实体）</p>
<p>  2.像String,Date,File,包装类重写了Object类的方法，比较两个对象中的实体内容是否相等</p>
<p>  3.对于自定义类来讲,如果没有重写Object类中equals（）方法，仍然比较两个对象的引用地址是否相同</p>
<p>  4.一般情况下，在开发中一旦调用了自定义了的equals()，通常是重写以后的equals()方法</p>
<p>  5.重写equals()方法的规则:比较两个对象的属性是否都相等</p>
<p> 面试题: == 和 equals() 区别 ?</p>
<p>　　　　== :使用范围:可以操作基本数据类型 和 引用数据类型</p>
<p>　　　　　　如果操作的是基本数据类型:比较两个基本数据类型变量的值是否相等</p>
<p>　　　　　　如果操作的是引用数据类型:比较两个引用的地址是否相同</p>
<p>　　　　equals:使用范围:只适用于引用数据类型</p>
<p>　　　　具体的使用:见上面的1-5</p>
<p>toString()的使用:</p>
<p>​        1.java.lang.Object 类中toString()定义如下: </p>
<p>​             public String toString(){  </p>
<p>​                     return getClass().getName()+”@”+Integer.toHexString(hashCode());  </p>
<p>​             }</p>
<p>​       2.当我们打印一个对象的引用时，实际上就是调用了toString方法 </p>
<p>​       3.像String,Date,File,包装类等重写了Object类中的toString方法，返回其代表的具体内容</p>
<p>​       4.对于自定义类而言，如果我们没有重写object类中toString方法，则返回的仍然是地址值</p>
<p>​           如果重写了的话，重写规则:返回当前对象的属性信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="顾思君"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">顾思君</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gusijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gusijun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/nightmare_dimple" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;nightmare_dimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">古俊</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">76k</span>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
