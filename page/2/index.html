<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"b2t":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="思君の博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="思君の博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="顾思君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>思君の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="思君の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思君の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">38</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day16/" class="post-title-link" itemprop="url">day16</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:57:16" itemprop="dateModified" datetime="2020-02-12T13:57:16+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.java中的容器–在内存层面,对数据进行统一的存储和管理:数组 ；java集合</p>
<p>​    扩展:数据的持久化:文件(.jpg;mp3); xml ; 数据库</p>
<p>2.数组在内存存储方面的特点:</p>
<p>　　①数组初始化以后,长度就确定了                </p>
<p>　　②数组类型声明后，就决定了进行元素初始化的类型   </p>
<p>弊端:数组初始化以后,长度就不可变了</p>
<p>　　数组中提供的属性和方法很少,不便于进行添加,删除,插入等操作            </p>
<p>　　数组存储的数据是有序的,可以重复的—–&gt;存储数据的特点单一    </p>
<p>　　String[] arr = new String[10]      </p>
<p>　　Object[]  </p>
<p>3.集合框架     </p>
<p>　java.util.Collection:单列数据</p>
<p>　|——-List子接口:存储有序的,可重复的数据—-&gt;“动态”数组</p>
<p>　　　|—–ArrayList:作为List的主要实现类,线程不安全的,效率高；底层使用数组</p>
<p>　　　|—–LinkedList:对于频繁的插入,删除操作，我们建议使用此类,效率高；底层使用双向链表实现       </p>
<p>　　　|—–Vector:List的古老实现类,线程安全的,效率低；底层使用数组实现</p>
<p>​     [面试题] ArrayList,LinkList,Vector区别?</p>
<p>　　　　共同点:ArrayList,LinkList,Vector都是List接口的实现类,存储的数据都是有序的,可重复的</p>
<p>　　　　　　　区别:如上</p>
<p>　　　　　　　List list = new ArrayList();</p>
<p>　　　　　　　list.add(..);</p>
<p>　　　　　　　…</p>
<p>　　　　　　　一旦添加元素超出底层数组的长度,就需要扩容,默认扩容需要为原来的1.5倍，同时              </p>
<p>　　　　　　　需要将原有数组中的元素复制到新的数组中。</p>
<p>实际情况:需要存储80个数据到ArrayList中,建议:List list = new ArrayList(85);            </p>
<p>　　　|——-Set子接口:存储无序的,不可重复的数据—-&gt;高中讲的“集合”</p>
<p>　　　　　　|—- HashSet 主要实现类,底层实现:HashSet底层使用了HashMap</p>
<p>　　　　　　|—- LinkedHashSet 是HashSet的子类,可以按照添加的顺序实现遍历     </p>
<p>　　　　　　　　(原因:在HashSet底层存储上的基础上,额外使用了一对指针,能够记录此Node元素的</p>
<p>　　　　　　　　 上一个元素和下一个元素) —&gt; 对于频繁的遍历，效率高</p>
<p>　　　　　　|—- TreeSet : 可以按照添加元素的指定属性的大小实现遍历。底层实现：红黑树</p>
<p>　　　　　　 TreeSet的使用</p>
<p>　　　　　　　　　1.向TreeSet中添加的元素必须是同一个类创建的对象</p>
<p>　　　　　　　　　2.TreeSet排序的方式:①自然排序 ②定制排序</p>
<p>　　　　　　　　　3.自然排序: </p>
<p>　　　　　　　　　　　①要求添加的元素所在的类实现Compare接口 </p>
<p>　　　　　　　　　　　②重写接口中的CompareTo(Object obj)—&gt;指明排序的规则</p>
<p>　　　　　　　　　　　　如果此方法返回值0，则要新添加的元素添加不成功</p>
<p>　　　　　　　　　　　③向TreeSet添加此实现类的对象即可</p>
<p>　　　　　　　　　定制排序：</p>
<p>　　　　　　　　　　　TreeSet的定制排序:     </p>
<p>　　　　　　　　　　　　1.提供Comparator接口匿名实现类的对象 </p>
<p>　　　　　　　　　　　　2.重写其中的compare(Object o1,Object o2),指明排序的规则 </p>
<p>　　　　　　　　　　　　3.将此实现类的对象作为参数传递到TreeSet的构造器中   </p>
<p>　　　　　　　　　　　　4.向TreeSet的对象中添加compare()方法中判断类的对象</p>
<blockquote>
<p>　总结:   元素是否能add成功,是否能remove,是否contains…..</p>
<p>　　　　都依赖于compareTo或者compare方法   与元素所在类的hasCode/equals无关</p>
</blockquote>
<p>set作为Collection的子接口,没有定义额外的方法set:存储无序的,不可重复的元素  </p>
<ol>
<li><p>无序性！= 随机性.添加的元素,需要计算哈希值,此哈希值决定了在底层储存的位置,从存储位置上看,  是无序的</p>
</li>
<li><p>不可重复性:保证set集合中不同对象使用对象所属类的equals()方法判断的话,一定返回false。</p>
</li>
<li><p>如何向Set中添加一个元素?哈希算法   </p>
</li>
</ol>
<p>　　　向Set中添加元素a,首先通过hasCode()，计算元素的哈希值,此哈希值就决定了此元素在Set底层</p>
<p>　　　存储的位置，如果此存储位置上没有元素,则此元素a添加成功 ，如果此存储的位置上有元素b,则</p>
<p>　　　调用元素a所在类的equals（）方法.将元素b作为参数传递过去,如果返回值为true，则表示元素</p>
<p>　　　a和元素b相同，添加不成功，如果返回值为false,则认为元素a和元素b不相同,此时元素b可以添</p>
<p>　　　加成功的.元素a和元素b使用链表存储（jdk7.0:a指向b；JDK8.0:b指向a）  </p>
<p>　4.向Set中添加的元素,要求其所在的类要重写两个方法:  equals() 和 hashCode() </p>
<p>　5.必须要求添加的元素所在的类中重写equals() 和 hashCode（）保持一致</p>
<p>Map:存储的是双列数据：key-value </p>
<p>　1.所有的key构成的是集合是set:无序的,不可重复的 </p>
<p>　2.所有value构成的是集合Collection:无序的,可以重复的 </p>
<p>　3.一个key-value构成一个Entry</p>
<p>　4.所有的Entry构成的集合是Set:无序的,不可重复的</p>
<p>　HashSet的底层使用HashMap存储的</p>
<p>　HashMap的所有key构成的集合是HashSet</p>
<p>|—-HashMap:Map的主要实现类,线程不安全,效率高；可以存储null的key和value</p>
<p>　　 (存储结构：Jdk7.0数组+链表,Jdk8.0数组+红黑树) </p>
<p>　　|—-LinkedHashMap:HashMap的子类,可以按照添加的顺序遍历,对于频繁的遍历效率</p>
<p>　　(在HashMap存储的基础上,使用了一对指针,来记录添加元素的顺序)</p>
<p>|—-TreeMap：可以按照key的指定的属性进行排序,遍历,底层实现:红黑树</p>
<p>|—-Hashtable：Map的古老实现类:线程安全,效率低;不可以存储null的key和value </p>
<p>　　　|—-Properties:Hashtable的子类，常常用来处理属性文件，其key和value都是String类型的</p>
<p>Map常用方法：</p>
<p>　添加:put(Object key,Object value)</p>
<p>　修改:put(Object key,Object value)</p>
<p>　删除:Object remove(Object obj)</p>
<p>　长度:size()</p>
<p>　清空数据:clear()</p>
<p>　是否为空isEmpty()</p>
<p>1.遍历所有的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Set keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">  Iterator iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123; </span><br><span class="line"></span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​     2.遍历所有的value</p>
<p>​       </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = map.values();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(Object obj:coll)&#123;  </span><br><span class="line"></span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>​    3.遍历所有的key-value</p>
<p>​          1.方式一：</p>
<p>​         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set keySet1 = map.keySet();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(Object key:keySet1)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(key+<span class="string">"----&gt;"</span>+map.get(key));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​         2.方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object o:entrySet)&#123; </span><br><span class="line"></span><br><span class="line">              Map.Entry entry = (Map.Entry)o;</span><br><span class="line"></span><br><span class="line">              System.out.println(entry.getKey()+<span class="string">"********"</span>+entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>Map常用方法：</p>
<ul>
<li>添加:put(Object key,Object value)</li>
<li>修改:put(Object key,Object value)</li>
<li>删除:Object remove(Object obj)</li>
<li>长度:size()</li>
<li>清空数据:clear()</li>
<li>是否为空isEmpty()</li>
</ul>
<p> 总结:</p>
<p>　　增：put(Object key,Object value)</p>
<p>　　删：Object remove(Object obj)</p>
<p>　　改：put(Object key,Object value)</p>
<p>　　查：get(Object key)</p>
<p>　　长度:size()</p>
<p>　　遍历:keySet() / values() / entrySet()List (index—&gt;数据)/ Set（很少用）/ Map（key –&gt; 数据）</p>
<p>   说明：1.向List中添加自定义类的对象的话,要求此定义类要重写equals()方法</p>
<p>　　　　2.补充:数据结构解决两个问题:</p>
<p>　　　　　　　1.数据之间逻辑关系：一对一，一对多，多对多…</p>
<p>　　　　　　　2.数据的存储结构:①顺序存储:一维数组 ②链式存储</p>
<p> 4.测试Collection中的常用方法</p>
<p>​       ①size（）返回集合中存储的元素的个数</p>
<p>​       ②add(Object obj) 将obj添加到当前的集合中</p>
<p>​       ③addAll(Collection coll) 将coll1集合中的所有元素添加到当前集合中</p>
<p>​       ④isEmpty() 判断当前集合是否为空</p>
<p>​       ⑤clear 清除当前集合</p>
<p>​       ⑥contains(Object obj) 判断当前集合中是否包含obj：调用了obj所在类的equals（）方法</p>
<p>​       ⑦containsAll(collection coll)    当前集合是否包含coll中的所有元素</p>
<p>​       ⑧remove(Object obj):从当前集合中移除obj元素.仍然需要obj所在类的equals的方法</p>
<p>​       ⑨removeAll(Collection coll):差集:从当前集合中移除coll集合中的元素</p>
<p>​       ⑩retainAll(Collection coll)：交集：获取当前集合和coll共有的元素</p>
<p>​       ⑪equals(Object obj):比较当前对象和obj是否相等。</p>
<p>​       ⑫hashCode():获取当前对象的哈希值</p>
<p>​       ⑬toArray()：将集合转换成数组:Object[]</p>
<p>​       ⑭toArrays(T[] arr):略</p>
<p>​       ⑮Iterator():集合元素的遍历。迭代器</p>
<p>​          hasNext():判断是否还有下一个元素</p>
<p>​          next():①指针下移 ②将指针下移以后集合位置上的元素返回</p>
<p>5.规定：如果集合中存储自定义类的对象，要求自定义重写equals方法</p>
<p>6.集合：很常用。</p>
<p>　　掌握点：层次一：选择合适的集合类实现数据的保存,调用其内部的相关方法</p>
<p>　　　　　　层次二:不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</p>
<p> 集合的遍历:</p>
<p>　方式一：使用Iterator实现</p>
<p>　方式二：增强for循环(foreach循环)</p>
<p>　　　　　for(集合元素的类型 局部变量 : 集合引用)</p>
<p>List:</p>
<p>在Collection的基础上，新增的方法：</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 </li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置.如果不存在，返回-1.</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置.如果不存在，返回-1.</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为eleList</li>
<li>subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合    </li>
<li>substring(int from ,int to) /  read(int from,int length)  </li>
</ul>
<p>​      总结：List中的常用方法：</p>
<p>　　　增：add(Object obj)</p>
<p>　　　删：remove(Object obj) / remove(int index)  </p>
<p>　　　改：set(int index, Object ele)</p>
<p>　　　查：get(int index)</p>
<p>　　　插：add(int index, Object ele)</p>
<p>　　　遍历：iterator();增强for;for   </p>
<p>　　　长度：size()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day20/" class="post-title-link" itemprop="url">day20</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:19:01" itemprop="dateModified" datetime="2020-02-12T14:19:01+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk 7.0 时，引入了 Path、Paths、Files三个类。</p>
<p>　1.此三个类声明在：java.nio.file包下。</p>
<p>　2.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关</p>
<p>　3.如何实例化Path:使用Paths. </p>
<p>　　static Path get(String first, String … more) : 用于将多个字符串串连成路径</p>
<p>　　static Path get(URI uri): 返回指定uri对应的Path路径 </p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path:"></a>Path:</h2><p>   String toString() ： 返回调用 Path 对象的字符串表示形式</p>
<p>   boolean startsWith(String path) : 判断是否以 path 路径开始</p>
<p>   boolean endsWith(String path) : 判断是否以 path 路径结束</p>
<p>   boolean isAbsolute() : 判断是否是绝对路径</p>
<p>   Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</p>
<p>   Path getRoot() ：返回调用 Path 对象的根路径</p>
<p>​       Path getFileName() : 返回与调用 Path 对象关联的文件名</p>
<p>​       int getNameCount() : 返回Path 根目录后面元素的数量(层数)</p>
<p>​       Path getName(int idx) : 返回指定索引位置 idx 的路径名称</p>
<p>​       Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</p>
<p>​       File toFile(): 将Path转化为File类的对象</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制      </p>
<p>​    &gt;要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</p>
<p>​      Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING); 当已存在时做覆盖</p>
<p>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录      </p>
<p>​      要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</p>
<p>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件      </p>
<p>​      要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</p>
<p>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</p>
<p>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</p>
<p>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置      </p>
<p>   要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</p>
<p>   Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</p>
<p>long size(Path path) : 返回 path 指定文件的大小</p>
<p>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</p>
<p>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</p>
<p>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</p>
<p>boolean isHidden(Path path) : 判断是否是隐藏文件</p>
<p>​    &gt;要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常</p>
<p>boolean isReadable(Path path) : 判断文件是否可读</p>
<p>boolean isWritable(Path path) : 判断文件是否可写</p>
<p>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</p>
<p>StandardOpenOption.READ:表示对应的Channel是可读的。 </p>
<p>StandardOpenOption.WRITE：表示对应的Channel是可写的。</p>
<p>StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略 StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常</p>
<p>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</p>
<p>DirectoryStream<Path>  newDirectoryStream(Path path) : 打开 path 指定的目录</Path></p>
<p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</p>
<p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</p>
<p>jdk 7 提供基于try-catch的自动资源管理</p>
<p>　能够实现资源的自动关闭，需要满足：</p>
<p>　　1.可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</p>
<p>　　2.需要关闭的资源，必须实现了 AutoCloseable 接口或其子接口 Closeable目的：不需要再使用finally，显式的关闭资源了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day18/" class="post-title-link" itemprop="url">day18</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:33:44" itemprop="dateModified" datetime="2020-02-12T13:33:44+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>泛型的应用:</p>
<p>　1.JDK 5.0 新增的特性</p>
<p>　2.主要内容：</p>
<p>　　2.1 在集合中使用泛型</p>
<p>　　2.2 如何自定义泛型类,泛型接口,泛型方法(理解)</p>
<p>　　2.3 泛型在继承上的体现(掌握)</p>
<p>　　2.4 通配符的使用（掌握）</p>
<p>在集合中使用泛型的情况</p>
<p>在集合中使用泛型</p>
<p>　1.在Java的集合中,声明的接口或者类已经声明泛型</p>
<p>　2.我们在实例化接口时,可以指明泛型的类型</p>
<p>　3.不能使用基本数据类型,需要使用对应的包装类替换</p>
<p>　4.一旦创建对象时,使用了泛型,则通过对象调用方法,属性时,如果方法或属性使用了类的泛型,   则此时泛型类型就是对象实例化时候的类型</p>
<p>　5.如果实例化时候,不指明泛型参数,则默认是Object类型</p>
<p>自定义泛型类:</p>
<p>　仿照List去创建</p>
<p>　1.在类的声明后面,指明泛型参数,参数通常使用:T E K V</p>
<p>　2.在类的属性,方法,构造器中,可以使用类的泛型参数</p>
<ul>
<li>使用了类的泛型参数的方法,不能声明为static的</li>
<li>不能在try-catch中使用泛型参数表示异常类型</li>
</ul>
<p>关于自定义泛型类,泛型接口,泛型方法的使用</p>
<p>　自定义泛型类的使用:</p>
<p>　　1.在实例化泛型类时,可以指明泛型的参数类型</p>
<p>　　2.提供泛型类的子类时,可以指明泛型的参数类型.比如:SubOrder1类</p>
<p>泛型在继承上的体现</p>
<p>　　1.如果A类是B类的父类,则List<A>与List<B>是没有子父类的关系的  </B></A></p>
<p>　　　扩展：则G<A> 和 G<B>没有子父类关系！</B></A></p>
<p>　　2.如果A类是B类的父类,则A<G> 是 B<G>的父类</G></G></p>
<p>通配符: ? 的使用：</p>
<p>　　A类是B的父类,则G<A> 和 G<B> 的公共父类为G&lt;?&gt;</B></A></p>
<p>　关于数据的读写问题</p>
<p>　写入数据:不允许向使用通匹配符的集合中写入数据，除非可以写入null</p>
<p>　读取数据：可以从使用了通配符的集合中读取数据。读取的数据的类型默认是Object</p>
<p>有限制条件的通配符的使用? </p>
<p>？  extends A:举例:List&lt;? extends A&gt; 可以作为List<B>或者List<A>的父类,其中B类是A类的子类?</A></B></p>
<p>？   super A: 举例:List&lt;? super A&gt; 可以作为List<B>或List<A>的父类,其中B类是A类的父类</A></B></p>
<p>File类：</p>
<p>　 1.java.io包下定义的</p>
<p>　 2.一个File类的对象，既可以表示一个文件(.txt,.mp3,.avi,mp4,.doc)，也可以表示一个文件目录。</p>
<p>　 3.File类中只涉及到文件或文件目录的新建、删除、长度、修改时间、重命名等操作。没有涉及到对文件内容的修改。如果需要对文件内容进行修改的话，需要使用流。</p>
<p>　 4.File类的对象常常作为流的构造器的参数出现。</p>
<p>　 5.File类的对象代表着流资源读取或写入到的文件。</p>
<p>  File类的实例化 </p>
<p>  　 绝对路径：包含盘符在内的文件或文件目录的完整路径 </p>
<p>  　 相对路径：相较于某一层文件路径来讲。比如：在Eclipse中的相对路径是相较于当前工程的。 </p>
<p>   两个构造器： </p>
<p>　　File(String pathname) </p>
<p>　　File(String parent,String pathname)</p>
<p>获取文件名:</p>
<p>getName()</p>
<p>getPath()</p>
<p>getAbsoluteFile()</p>
<p>getAbsolutePath()</p>
<p>getParent()</p>
<p>toPath()</p>
<p>renameTo(File newName)</p>
<p>   file1.renameTo(File file2):file1重命名为file2是否成功</p>
<p>   如果希望返回值为true.则必须：file1对应的物理磁盘上的文件需要存在，且file2对应的物理磁盘上的文件不存在。</p>
<p>文件检测:</p>
<p>   exists()</p>
<p>   canWrite()</p>
<p>   canRead()</p>
<p>   isFile()</p>
<p>   isDirectory()</p>
<p>获取文件常规信息:</p>
<p>   lastModified()</p>
<p>   length()</p>
<p>  操作文件相关的：</p>
<p>​    createNewFile()：在物理磁盘上创建指定路径的文件</p>
<p>​    delete():删除物理磁盘上指定路径的文件</p>
<p>  操作文件目录相关的：</p>
<p>​    mkdir()/mkdirs():如果要创建的文件目录的上层目录存在，则二者没有区别。</p>
<p>​    如果要创建的文件目录的上层目录不存在，mkdir()创建不成功，mkdirs()创建成功。</p>
<p>   delete()：删除物理磁盘上指定路径的文件目录list()listFiles()</p>
<p>list() / listFiles()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day17/" class="post-title-link" itemprop="url">day17</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:36:35" itemprop="dateModified" datetime="2020-02-12T13:36:35+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>731</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Collections:用来操作集合框架(Collection / Map)的工具类</p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object  </li>
<li>object min(Collection)</li>
<li>Object min(Collection，Comparator)</li>
<li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li>
</ul>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中</li>
</ul>
<p>　　List dest = Arrays.asList(new Object[list.size()]);</p>
<p>　　Collections.copy(dest, list);</p>
<p>　　System.out.println(dest);</p>
<ul>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li>
</ul>
<p>  list:线程不安全的。</p>
<p>  List newList = Collections.synchronizedList(list);</p>
<p>  newList:线程安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day19/" class="post-title-link" itemprop="url">day19</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:30:28" itemprop="dateModified" datetime="2020-02-12T13:30:28+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  一、流的分类</p>
<p>　1.流的流向：输入流、输出流</p>
<p>　2.流中数据单位：字节流、字符流</p>
<p>　3.流的角色不同：节点流、处理流</p>
<p>  二、 抽象基类                          节点流(或文件流)                                       缓冲流(处理流的一种)：提高数据读写效率</p>
<p>​          InputStream                   FileInputStream(read(byte[]))                 BufferedInputStream(read(byte[])</p>
<p>​          OutputStream               FileOutputStream(write(byte[],0,len))  BufferedOutputStream(write(byte[],0,len)</p>
<p>​         Readed                            FileReader(read(char[]))                          BufferedReader(read(char[]) / readLine())</p>
<p>​         Writer                              FileWriter(write(char[],0,len))                  BufferedWriter(write(char[],0,len)</p>
<p>从指定文件中读取数据到控制台上</p>
<p>　1.要去读的文件一定要存在的,否则报FileNotFoundException</p>
<p>　2.因为需要保证流的资源关闭,所以异常的处理需要使用try-catch-finally</p>
<p>字节流：</p>
<p>　输入流:FileInputStream</p>
<p>　1.创建一个文件,指明读取数据的来源</p>
<p>　2.将file对象作为参数传递到流的构造器中,创建一个字节的输入流:FileInputStream</p>
<p>　3.read():读取文件中的下一个字节。如果到达文件末尾的话,返回-1</p>
<p>　4.关闭资源</p>
<p> 输出流:FileOutputStream</p>
<p>　1.造文件</p>
<p>　2.造流:输出流</p>
<p>　3.写出数据  getBytes()  字符串—&gt;字节数组</p>
<p>　4.关闭资源</p>
<p>　　* 如果输出的文件不存在,则在输出执行的过程中,自动创建此文件<br>　　* 如果输出的文件存在：如果使用构造器：FileOutputStream(file)是对已存在的文件的覆盖, </p>
<p>​                                              如果使用构造器:FileOutputStream(file,true)是在已有文件内容的基础上,继续写入内容</p>
<p>字符流</p>
<p>　 FileReader 和 FileWriter的使用：只能用来处理文本文件的。</p>
<p>　FileInputStream 和  FileOutputStream:适合用来处理非文本文件：.avi , .mp3, .jpg, .doc</p>
<p>   1.造文件</p>
<p>   2.造流：字符的输入流、字符的输出流</p>
<p>   3.读取数据并写出</p>
<p>   4.关闭资源</p>
<p>缓冲流的使用。</p>
<p>　1.缓冲流是处理流的一种</p>
<p>　2.作用：提高数据的读写效率</p>
<p>　3.类： 处理非文本文件：</p>
<p>　　　BufferedInputStream</p>
<p>　　　BufferedOutputStream</p>
<p>　　　　处理文本文件：</p>
<p>　　　BufferedReader</p>
<p>　　　BufferedWriter  —&gt;readLine 读取一行</p>
<p>　　　　　　　　　　　—&gt;newLine 开始新的一行</p>
<p>理流之二：转换流</p>
<p>　1.转化流的作用：能够实现字节流与字符流之间的转换</p>
<p>　2.涉及到的流：</p>
<p>　　　InputStreamReader:实现字节的输入流转换为字符的输入流</p>
<p>　　　OutputStreamWriter:实现字符的输出流转换为字节的输出流</p>
<p>　　编码的过程：字符串、字符数组—&gt;字节数组</p>
<p>　　解码的过程：字节数组—-&gt;字符串、字符数组</p>
<p> 3.常见的编码集：</p>
<p>　ASCII：美国标准信息交换码，用一个字节的7位可以表示。</p>
<p>　ISO8859-1：拉丁码表。欧洲码表.  用一个字节的8位表示。</p>
<p>　GB2312：中国的中文编码表。</p>
<p>　GBK：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p>　Unicode：国际标准码，融合了多种文字。 所有文字都用两个字节来表示,Java语言使用的就是unicode</p>
<p>　UTF-8：最多用三个字节来表示一个字符</p>
<p>处理流之三：标准的输入、输出流 </p>
<p>　System.in:标准的输入流，默认从键盘输入 </p>
<p>　<em>System.out:标准的输出流，默认从显示屏输出</em> </p>
<p>　 System.setIn():重新指定输入的位置 </p>
<p>　System.setOut():重新指定输出的位置</p>
<p>处理流之四：打印流 PrintStream 和 PrintWriter</p>
<p>处理流之五：数据流 DataInputStream 和 DataOutpuStream</p>
<p>处理流之六：对象流</p>
<p>　1.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中， 也能把对象从数据源中还原回来。</p>
<p>　2.涉及到的流：ObjectInputStream 和 ObjectOutputStream</p>
<p>　3.对象序列化机制：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象.</p>
<p>提供一个自定义类，实现序列化机制。</p>
<p>　要求：1.自定义类实现Serializable接口</p>
<p>　　　　2.需要给当前的类声明全局的常量：serialVersionUID</p>
<p>　　　　3.要求类的属性也是可序列化的。 (默认情况下：String、基本数据类型都是可序列化的)</p>
<p>　　　　注意：不能序列化static和transient修饰的成员变量</p>
<p>RandomAccessFile的使用：随机存取文件流</p>
<p>　1.RandomAccessFile在java.io包下声明，直接继承于Object类</p>
<p>　2.既可以作为输入流，又可以作为输出流。</p>
<p>　3.如果输出到的文件不存在，则会在输出的过程中，自动创建此文件 。 如果输出到的文件存在，</p>
<p>　　则不是对文件的覆盖，而是对文件内容的覆盖。（默认从头覆盖）</p>
<p>　4.实现数据的“插入” </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day2/" class="post-title-link" itemprop="url">day2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:01:06" itemprop="dateModified" datetime="2020-02-12T15:01:06+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>赋值运算符 = </p>
<p>支持链式赋值 a  = b = 99</p>
<p>复合赋值运算符 (+=  , -=  , /= , *=)</p>
<p>short a = 10;</p>
<p>a += 2  与 a = a +2 相似，有区别的</p>
<p>a += 2     相当于a自增,不会改变本身变量数据类型</p>
<p>a = a +2  因为整型常量默认是int，所以a+2，自动提升数据类型为int,会报错</p>
<p>真正开发中，如果希望变量自增1：</p>
<p> 方式1： i = i + 1</p>
<p> 方式2： i += 1</p>
<p> 方式3： i++   (推荐)</p>
<p>真正开发中，如果希望变量自增2：</p>
<p> 方式1： i = i + 2</p>
<p> 方式2： i += 2  (推荐)</p>
<p>比较运算符： ==    !=    &gt;  &lt;   &gt;=  &lt;=  instanceof</p>
<p>比较运算符的结果都是布尔类型（boolean）</p>
<p>逻辑运算符：运算符操作的是boolean型变量，运算结果也是boolean类型</p>
<p>&amp;逻辑与运算符     &amp;&amp; 短路与</p>
<p>|逻辑或运算符      ||   短路或    </p>
<p>！逻辑非运算符     ^    逻辑异或</p>
<p>&amp;和&amp;&amp;运算结果相同，如果符号左边是true,两个运算符都要执行右边的运算</p>
<p>​                                       如果符号左边是false,&amp;仍然要执行右边的，&amp;&amp;不在执                            </p>
<p>​                                        行符号右边的</p>
<p>|和||运算结果相同，  如果符号左边是true,   |仍然要执行右边的，||不在执                            </p>
<p>​                                        行符号右边的</p>
<p>​                                        如果符号左边是false,两个运算符都要执行右边的运算</p>
<p>​                                         </p>
<p>位运算符：操作的都是数值型变量</p>
<p>&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;(无符号右移)  &amp;  |  ^  ~</p>
<p>&lt;&lt; 规律：在一定范围内，每左移一位，相当于数值*2，过犹不及(截断是让数值变的更小)</p>
<p>。&gt;&gt; 规律：在一定范围内，每右移一位，相当于数值/2，过犹不及。</p>
<p>。&gt;&gt;&gt;:右移以后最高位拿0补</p>
<p>三元运算符：（条件表达式）？表达式1：表达式2</p>
<p>​                           表达式1和表达式2的数据类型要一致（满足自动类型提升也可以）</p>
<p>三元运算符一定可以转换为if else,反之不成立</p>
<p>顺序结构：</p>
<p>前向引用</p>
<p>分支结构：</p>
<p>if(条件表达式){</p>
<p>​    执行代码块</p>
<p>}</p>
<p>if(条件表达式){</p>
<p>​    执行代码块1</p>
<p>}</p>
<p>else{</p>
<p>​     执行代码块2</p>
<p>}</p>
<p>if(条件表达式1){</p>
<p>​    执行代码块1</p>
<p>}</p>
<p>else if(条件表达式2){</p>
<p>​     执行代码块2</p>
<p>}</p>
<p>else{</p>
<p>​         执行代码快n</p>
<p>}</p>
<p>1.else：结构可选的</p>
<p>2.如果两个条件表达式没有公共的交集，此时两个else if结构，可以交换结构</p>
<p>   .如果两个条件表达式有公共的交集，要求范围小的条件表达式放在条件表达式的上面，</p>
<p>​    此时两个条件表达式才有可能都被执行到</p>
<blockquote>
<p> 从键盘获取数据</p>
</blockquote>
<ul>
<li><p>导包</p>
<p>import java.util.Scanner;</p>
</li>
<li><p>实例化Scanner</p>
</li>
<li><p>调用相关方法，获取不同类型的变量</p>
<p>next 字符串</p>
<p>nextInt 整数</p>
<p>nextDouble  double</p>
<p>nextFloat       float  </p>
<p>nextBoolean  布尔类型</p>
<p>Scanner类中没有从键盘获取char的方法</p>
<p>用户输入的变量类型与调用的方法类型需要一致，否则，报inputMismatchException</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day21/" class="post-title-link" itemprop="url">day21</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:21:40" itemprop="dateModified" datetime="2020-02-12T13:21:40+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、NIO的使用中两个重要的要素：</p>
<p>　缓冲区(Buffer)、通道(Channel)</p>
<p>　缓冲区(Buffer):存储数据的。   —-&gt;byte[] buffer = new byte[1024]</p>
<p>　通道(Channel)：代表着数据源与目标节点之间的连接，负责缓冲区的传输。 —&gt;IO流</p>
<p>　二者的交互：Java NIO 中的 Buffer 主要用于与 NIO 通道(Channel)进行交互， 数据是从通道读入缓冲  区，　从缓冲区写入通道中的。</p>
<p>二、缓冲区（Buffer）的结构 (除boolean之外) </p>
<p>　java.nio.Buffer抽象类</p>
<p>　　|—-ByteBuffer</p>
<p>　　|—-CharBuffer</p>
<p>　　|—-ShortBuffer</p>
<p>　　|—-IntBuffer</p>
<p>　　|—-LongBuffer</p>
<p>　　|—-FloatBuffer</p>
<p>　　|—-DoubleBuffer</p>
<p> XxxBuffer底层使用xxx[]进行存储。</p>
<p> 三、如何实例化缓冲区？调用缓冲区类XxxBuffer的静态方法：allocate(int capacity)   </p>
<p>　　举例：ByteBuffer byteBuffer = ByteBuffer.allocate(10);byte[] hb = new byte[10];</p>
<p>　　类似：ArrayList list = new ArrayList(10);//Object[] eleData = new Object[10];</p>
<p>　说明：方法的形参，决定了底层创建的数组的长度</p>
<p>四、Buffer中的常用属性：</p>
<p>　　capacity:容量，决定了底层数组的长度，表明了最大存储数据的容量</p>
<p>　　limit:限制，默认情况下，limit等于capacity.在读数据模式下，limit&lt;=capacity.表明最大可以读取数据的量position:位置，表明了当前读取或写入数据的位置</p>
<p>　　mark:标记。默认值为-1.</p>
<p>　　关系式：mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>　　类比：项目三中TeamService类中的属性：</p>
<p>　　　private final int MAX_MEMBER = 5;//相当于capacity  </p>
<p>　　　private Programmer[] team = new Programmer[MAX_MEMBER];//Buffer底层封装的数组  </p>
<p>　　　private int total;//相当于limit</p>
<p>　　　index:读取、写入数组指定为的索引：position</p>
<p>五、Buffer中的常用方法：</p>
<p>　　1）最基本的两个方法：put(Xxx xxx) / get()</p>
<p>　　2）其他方法：见ppt中的表格即可。</p>
<p> 六、针对于ByteBuffer来讲，可以创建非直接缓冲区：allocate(int capacity)</p>
<p>​         直接缓冲区：allocateDirect(int capacity) / FileChannel 的 map()</p>
<blockquote>
<p>了解非直接缓冲区 与 直接缓冲区的区别</p>
</blockquote>
<p>byteBuffer.put(“hello”.getBytes());//写入长度为5的字节数.每put一个字节，position就+1</p>
<p>byteBuffer.flip();//切换为读数据模式。将limit设置为position，position归零</p>
<p>byteBuffer.rewind();//重置position</p>
<p>byteBuffer.clear();//清空.将position归零，limit设置为capacity.数据并未删除。</p>
<p>byteBuffer.get(dst,0,2);//从数组角标0开始，写入两个字节的数组</p>
<p>if(byteBuffer.hasRemaining()){</p>
<p>//判断是否还有元素没有读取到。   </p>
<p>​        System.out.println(byteBuffer.remaining());//还有几个没有读取到。</p>
<p>   }System.out.println();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day24/" class="post-title-link" itemprop="url">day24</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:16:58" itemprop="dateModified" datetime="2020-02-12T13:16:58+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>497</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、要想实现网络通信，需要解决两个问题：</p>
<p>　　1.如何准确的定位互联网上的一台或多台主机 </p>
<p>　　2.如何实现可靠而高效的数据传输</p>
<p> 二、网络通信的两个要素：</p>
<p>　　1.使用IP地址，定位网络中的主机</p>
<p>　　2.遵循相关的网络通信协议</p>
<p> 三、针对要素一：</p>
<p>　　1.IP：一个ip地址，对应着网络中的一台主机。 “192.168.20.16”   “127.0.0.1”–本地回路地址</p>
<p>　　　　使用InetAddress类来代表IP，一个InetAddress类的对象，就代表着一个具体的ip地址。</p>
<p>　　２.如何实例化InetAddress:</p>
<p>　　　　①getByName(String hostName)</p>
<p>　　　　②getLocalHost()</p>
<p>　　3.域名： <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>   <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a>   <a href="http://www.mi.com" target="_blank" rel="noopener">www.mi.com</a>  <a href="http://www.vip.com" target="_blank" rel="noopener">www.vip.com</a></p>
<p>　　　　　　 <a href="http://www.facebook.com" target="_blank" rel="noopener">www.facebook.com</a></p>
<p>​         localhost对应着127.0.0.1</p>
<p>　　4.InetAddress类的常用方法：getHostName() / getHostAddress()</p>
<p>　　5.端口号标识正在计算机上运行的进程（程序）</p>
<p>　　　　注意：不同的进程有不同的端口号</p>
<p>　　　　常见的端口号： http:80   tomcat : 8080   mysql：3306  oracle:1521等</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day22/" class="post-title-link" itemprop="url">day22</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:16:00" itemprop="dateModified" datetime="2020-02-12T13:16:00+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、继承Thread的方式</p>
<p>　　1.提供一个继承于Thread类的子类</p>
<p>　　2.重写Thread类的run():将创建的线程要执行的操作，声明在run()中。</p>
<p>　　3.实例化Thread子类</p>
<p>　　4.调用子类对象的start() </p>
<p>Thread类的常用方法的测试</p>
<p> 　　1.run():Thread的子类一定要重写的方法。将此分线程要执行的操作，声明在run()中</p>
<p>　 　2.start():要想启动一个分线程，就需要调用start():①启动线程②调用线程的run()</p>
<p>　 　3.currentThread():静态方法，获取当前的线程</p>
<p>　 　4.getName():获取当前线程的名字</p>
<p>　 　5.setName(String name)：设置当前线程的名字</p>
<p>　 　6.yield():当前线程调用此方法，释放CPU的执行权</p>
<p>　 　7.join():在线程a中调用线程b的join()方法:只用当线程b执行结束以后，线程a结束阻塞状态，继续执行。</p>
<p>　　 8.sleep(long millitimes):让当前的线程睡眠millitimes毫秒</p>
<p>　 　9.isAlive():判断当前线程是否存活 </p>
<p>　　10.线程的优先级：</p>
<p>　　　　 MAX_PRIORITY：10 </p>
<p>　　　　NORM_PRIORITY：5 —默认优先级</p>
<p>　　　　MIN_PRIORITY：1</p>
<p>​    　 设置优先级：setPriority(int priority); </p>
<p>​    　 获取优先级：getPriority()；</p>
<blockquote>
<p>设置优先级以后，对高优先级，使用优先调度的抢占式策略，抢占低优先级的执行。但是并不意味着高优    先级的线程一定先于低优先级的线程执行，而是从概率上来讲，概率更大而已。</p>
</blockquote>
<p> 线程通信：wait() / notify() / notifyAll()  —-&gt;java.lang.Object类中定义的方法</p>
<h4 id="一：继承Thread的方式"><a href="#一：继承Thread的方式" class="headerlink" title="一：继承Thread的方式"></a>一：继承Thread的方式</h4><p>　　　1.提供一个继承Thread类的子类 </p>
<p>　　　2.重写Thread类run():将创建的线程要执行的操作,声明在run()中 </p>
<p>　　　3.实例化Thread子类</p>
<p>　　　4.调用子类对象的start()方法</p>
<h4 id="创建多线程的方式二"><a href="#创建多线程的方式二" class="headerlink" title="创建多线程的方式二:"></a>创建多线程的方式二:</h4><p>　　　1.创建一个实现Runnable接口的类</p>
<p>　　　2.实现Runnable的run()</p>
<p>　　　3.创建当前实现类的对象</p>
<p>　　　4.将此对象作为参数传递到Thread类的构造器中,创建Thread类的对象</p>
<p>　　　5.通过Thread类的对象调用其start()</p>
<p>对比继承Thread类和实现Runnable接口的方式</p>
<p>　　　1.联系:public class Thread implements Runnable</p>
<p>　　　2.相同点:启动线程,使用的是同一个start()方法</p>
<p>　　　3.对比:实现Runnable接口要好一些. </p>
<p>　原因：①不影响类的继承,因为类是单继承的   </p>
<p>　　　　②针对于有共享数据的操作,更适合使用Runnable的方式 ,换句话说,实现Runnable接口的方式,实现了代                    码和数据的分离</p>
<p>　　　4.面试题:创建多线程有几种方法?     继承Thread类,实现Runnable接口,实现Callable接口,使用线程池</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张。—–使用实现的方式</p>
<p>　　1.问题：出现了重票和错票</p>
<p>　　2.问题出现的原因：一个窗口在没有售完票的情况下，其他的窗口参与进来，操作ticket，导致ticket输出的错            误。</p>
<p>　　3.解决的方案：当某一个窗口完全操作完ticket以后，其他窗口应该才被允许进来，继续操作ticket。</p>
<p>　　4.java如何实现的？同步机制：①同步代码块    ②同步方法 </p>
<p>　　　4.1 同步代码块：</p>
<p>​                 synchronized(同步监视器){</p>
<p>​                       //需要被同步的代码</p>
<p>​               }</p>
<p>　　　说明：需要被同步的代码：即为操作共享数据的代码</p>
<p>　　　　　　共享数据：多个线程共同操作的数据。比如：ticket</p>
<p>　　　　　　同步监视器：俗称：锁。 可以由任何一个类的对象充当。 要求：保证多个线程共用同一把锁！</p>
<p>　　　4.2 同步方法：将操作共享数据的方法，声明为同步的。此方法即为同步方法。</p>
<p>　　　　　使用同步方法解决实现方式的线程安全问题。</p>
<p>　　　　　1.默认的同步方法（非静态的）的锁是：当前对象，也就是this.</p>
<p>　　　　　2.默认的同步方法（静态的）的锁是：当前类本身.</p>
<p>　　　　　　使用同步方法解决继承方式的线程安全问题：</p>
<p>　　　　　注意：继承的方式中，要慎用同步方法。</p>
<p>​        5.好处：线程的同步机制，解决了线程的安全问题。</p>
<p>​        6.劣势：在操作共享数据过程中，是单线程的。</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张     —–使用实现的方式</p>
<p>　　解决线程安全问题的方式三：ReentrantLock</p>
<p>　　存在线程的安全问题，使用Lock的方式解决线程安全问题。</p>
<p>面试题：同步的方式和Lock的方式，解决线程安全方面的异同？</p>
<p>　　同：解决了线程安全问题</p>
<p>　　异：同步的方式：同步监视器在线程执行完操作共享数据的代码以后，自动释放</p>
<blockquote>
<p> Lock的方式：需要显式的调用unlock()方法之后，才能保证其他线程操作共享数据。 </p>
</blockquote>
<p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，是我们开发中需要规避的！</p>
<p>线程的通信：</p>
<ul>
<li><p>wait():一个线程在执行过程中，一旦调用此方法，则此线程进入阻塞状态，等待其他线程来唤醒自己。    </p>
</li>
<li><p>notify():一个线程在执行过程中，一旦调用此方法，则会唤醒被wait()的一个线程。高优先级的要优先被唤醒。</p>
</li>
<li><p>notifyAll():一个线程在执行过程中，一旦调用此方法，则会唤醒所有被wait()的线程。</p>
</li>
</ul>
<p>　　　例题：使用两个线程打印 1-100. 线程1, 线程2 交替打印</p>
<p>注意点：1.此三个方法必须使用在同步中。</p>
<p>　　　　2.此三个方法的调用者是同步监视器！否则，如果三个方法的调用者不是同步监视器，报异常。</p>
<p>　　　　3.此三个方法定义在Object类</p>
<p>面试题：sleep() 和  wait() 的异同？</p>
<p>　　1.方法声明在哪？ Thread:sleep()   Object:wait()</p>
<p>　　2.共同点：使得当前线程进入阻塞状态</p>
<p>　　3.使用的范围要求：sleep()使用没有情境的要求；wait()必须使用在同步代码块或同步方法中</p>
<p>　　4.都使用在同步当中的话：wait()需要唤醒：notify()/notifyAll();  sleep():不会释放锁；wait()会释放锁 </p>
<p> String:字符串</p>
<p>　　　1.字符串声明的数据，会存储在字符串常量池中。第一次声明时，需要创建相应的字符串。之后，如果声明的变量，其值与之前存在的字符串内容相同，则直接引用现成的字符串。</p>
<p>　　　2.面试题：String s3 = new String(“javaEE”);创建的对象，在内存中生成了几个对象？</p>
<p><strong>String:代表着不可变的字符序列。</strong></p>
<p>　　　1.String类的声明public final class String implements java.io.Serializable, Comparable<String>, 　　　　CharSequence</String></p>
<p>　　　　　①String声明为final，不可被继承。</p>
<p>　　　　　②实现Serializable：表明String可序列化。浏览器/客户端&lt;—&gt;服务器端     进程1&lt;—-&gt;进程2    　　　　　　“{name=Tom,age=12}”    JSON:本质就是String</p>
<p>　　　　　③String重写了hashCode()/equals():常常将Map的key声明为String型。</p>
<p>　　　　　④实现Comparable接口：String可以比较大小。</p>
<p>　　　　　⑤实现CharSequence接口：String的底层声明了char[] value数组。</p>
<p>　　　2.如何理解String的不可变性：</p>
<p>　　　　　①向现有的字符串后添加新的字符串，必须声明新的字符串空间</p>
<p>　　　　　②将现有的字符串替换为新的字符串，必须声明新的字符串空</p>
<p>　　　　　③只替换现有字符串中的指定某个字符，也必须声明新的字符串空间</p>
<p>String类与其它结构的转换：</p>
<p>　　　1.String 与包装类、基本数据类型变量间的转换    </p>
<p>　　　　String–&gt;包装类、基本数据类型:调用包装类Xxx的parseXxx(String s)方法</p>
<p>　　　　包装类、基本数据类型 –&gt;String:调用String的valueOf(xxx xxx); </p>
<p>　　　2.String 与 字节数组间的转换   </p>
<p>　　　　String –&gt; 字节数组:调用String类的getBytes()</p>
<p>　　　　字节数组–&gt;String:new String(byte[] buffer,startIndex,length)</p>
<p>　　　3.String 与 字符数组间的转换</p>
<p>　　　　String –&gt; 字符数组：调用String类的toCharArray()</p>
<p>　　　　字符数组 –&gt;String:new String(char[] cbuf,startIndex,length)    </p>
<p>​         </p>
<ul>
<li><p>public String substring(int startpoint):返回当前字符串中从startPoint位置开始，到末尾的子字符串。  </p>
</li>
<li><p>public String substring(int start,int end):返回当前字符串中从startPoint位置开始，到end结束的左闭右开区间的子字符串。</p>
</li>
<li><p>pubic String replace(char oldChar,char newChar):将字符串中指定的所有oldChar替换为newChar.</p>
</li>
<li><p>public String replaceAll(String old,String new):将字符串中指定的所有old替换为new.</p>
</li>
<li><p>public String trim():去除字符串首尾的空格</p>
</li>
<li><p>public String concat(String str):连接两个字符串</p>
</li>
<li><p>public boolean contains(CharSequence s)：判断当前字符串中是否包含s.</p>
</li>
<li><p>public String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。</p>
</li>
</ul>
<ul>
<li><p>public int length():返回当前字符串的长度</p>
</li>
<li><p>public char charAt(int index)：获取指定索引位置的字符</p>
</li>
<li><p>public boolean equals(Object anObject)：比较两个字符串内容是否相等。</p>
</li>
<li><p>public int compareTo(String anotherString):比较两个字符串的大小</p>
</li>
<li><p>public int indexOf(String s):返回s在当前字符串中首次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int indexOf(String s ,int startpoint):</p>
</li>
<li><p>public int lastIndexOf(String s):返回s在当前字符串中末次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int lastIndexOf(String s ,int startpoint):</p>
</li>
<li><p>public boolean startsWith(String prefix)：判断当前的字符串是否以指定的prefix字符串开始的</p>
</li>
<li><p>public boolean endsWith(String suffix)：判断当前的字符串是否以指定的suffix字符串结束的</p>
</li>
<li><p>public boolean regionMatches(int firstStart,String other,int otherStart ,int length)   ？</p>
</li>
</ul>
<p>面试题：</p>
<p>　　String:不可变的字符序列；底层使用char[]存储</p>
<p>　　StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储  </p>
<p>　　StringBuilder:可变的字符序列；线程不安全的，效率高，(jdk 5.0新增)；底层使用char[]存储</p>
<p>类比：String —&gt;数组； StringBuffer —&gt;Vector   StringBuilder —&gt;ArrayList</p>
<p>　　　ArrayList list = new ArrayList();</p>
<p>　　　list.add(123);//new Object[10];</p>
<p>　　　….</p>
<p>　　　扩容:1.5倍的方式扩容。</p>
<p>　　　这里：</p>
<p>　　　　String str = new String();//new char[0];</p>
<p>　　　　str.length();</p>
<p>　　　　String str1 = new String(“abc”);//new char[]{‘a’,’b’,’c’};</p>
<p>　　　对比：</p>
<p>　　　　StringBuffer s1 = new StringBuffer();//char[] value = new char[16]</p>
<p>　　　　StringBuffer s2 = new StringBuffer(10);//char[] value = new char[10]</p>
<p>　　　　s1.append(“abc”);//value[0] = ‘a’,value[1] = ‘b’,value[2] = ‘c’;</p>
<p>　　　　　… </p>
<p>　　　　　　  每次添加时，都需要判断底层的char[]是否能够盛装下新要添加的字符串。</p>
<p>　　　　　　 如果不能盛装下，需要扩容。默认扩容为原来的2倍 + 2.   </p>
<p>　　　 启示：StringBuffer s1 = new StringBuffer(int capacity);开发中建议使用此构造器。</p>
<p>StringBuffer中的方法：</p>
<ul>
<li><p>StringBuffer append(String s),</p>
</li>
<li><p>StringBuffer append(int n) ,</p>
</li>
<li><p>StringBuffer append(Object o) ,</p>
</li>
<li><p>StringBuffer append(char n)，</p>
</li>
<li><p>StringBuffer append(long n),</p>
</li>
<li><p>StringBuffer append(boolean n),</p>
</li>
<li><p>StringBuffer insert(int index, String str)</p>
</li>
<li><p>public StringBuffer reverse()</p>
</li>
<li><p>StringBuffer delete(int startIndex, int endIndex):删除当前可变字符串中从startIndex到endIndex结束的左闭右开区间的数据。</p>
</li>
<li><p>public char charAt(int n )</p>
</li>
<li><p>public void setCharAt(int n ,char ch)</p>
</li>
<li><p>StringBuffer replace( int startIndex ,int endIndex, String str)</p>
</li>
<li><p>public int indexOf(String str)</p>
</li>
<li><p>public String substring(int start,int end)</p>
</li>
<li><p>public int length()</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　增：append(Xxx xxx)</p>
<p>　　删：delete(int startIndex, int endIndex</p>
<p>　　改：setCharAt(int n ,char ch) / replace( int startIndex ,int endIndex, String str)</p>
<p>　　查：charAt(int n)</p>
<p>　　插：insert(int index, String str)</p>
<p>　　长度：length()</p>
<p>　　遍历：使用for + charAt()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day3/" class="post-title-link" itemprop="url">day3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:58:45" itemprop="dateModified" datetime="2020-02-12T14:58:45+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>579</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>equals   判断字符串内容</p>
<p>Math.random  [0, 1)</p>
<p>想获取【a,b】的数 ( int )(Math.random()*(b-a+1)+a)</p>
<p>分支结构2：switch-case</p>
<p>switch 语句的结束标志： } ，break</p>
<p>default 可选，位置比较灵活</p>
<p>switch中的表达式所代表的数据类型6种，只能是如下byte,short,char,int,枚举，String(jdk7.0新增)</p>
<p>case 后只能是常量或者是常量表达式</p>
<p>多个case可以共用一组语句，在最后一个case上写要执行的语句就好了，这里的最后一个case并不是}附近的一个，而是你要停止的一个</p>
<p>凡是swith-case实现的结构，都可以转成if-else实现，反之不成立</p>
<p>字符串方法：</p>
<p>获取字符：charAt()</p>
<p>循环结构4要素：</p>
<p>初始化条件</p>
<p>循环条件  —&gt;布尔类型</p>
<p>循环体</p>
<p>迭代条件</p>
<p>当循环条件返回false,结束循环</p>
<p>for和while 可以相互转换</p>
<p>循环结构的结束方式：</p>
<p> 1.循环条件返回false时</p>
<p> 2.在循环体中，判断某个条件满足时，执行break (不确定循环次数时)</p>
<p>​     while(true)   / for(;;)</p>
<p>嵌套循环：</p>
<p>一个循环结构a,作为另一个循环结构b的循环体实现</p>
<p> 内层循环：循环结构a</p>
<p> 外层循环：循环结构b</p>
<p>技巧：</p>
<p>1.外层循环控制行数</p>
<p>   内层循环控制列数</p>
<p>2.</p>
<p>内层循环循环次数为m次，外层循环循环次数为n次，则一共循环m*n次</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="顾思君"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">顾思君</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gusijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gusijun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/nightmare_dimple" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;nightmare_dimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">古俊</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">72k</span>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
