<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"b2t":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="思君の博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="思君の博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="顾思君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>思君の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="思君の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思君の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">40</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day13/" class="post-title-link" itemprop="url">day13</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:26:06" itemprop="dateModified" datetime="2020-02-12T14:26:06+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>643</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java.util.Vector  动态数组</p>
<p>get（index）  </p>
<p>addElement(OBject obj)</p>
<p>size() </p>
<p>栈：局部变量</p>
<p>堆：new出来的结构，数组</p>
<p>方法区：类的加载信息，静态变量，常量</p>
<p>static关键字的使用:</p>
<ul>
<li><p>static:静态的</p>
</li>
<li><p>static可以用来修饰:属性,方法,代码块,内部类</p>
</li>
<li><p>使用static修饰属性:类变量（或静态变量</p>
</li>
<li><p>使用static修饰的变量被类的所有对象所共享，类的所有对象共用一个静态变量   </p>
<p>对比:不用static修饰的属性，称为:实例变量,每个对象拥有一份实例变量</p>
<p>　　　通过对象a修改某个实例变量，不会影响其他对象同名的实例变量的值。  </p>
<p>我们可以通过对象a去调用或修改静态变量的值,那抹会影响其他对象对此静态变量的调用   </p>
</li>
</ul>
<blockquote>
<p>静态变量和实例变量在内存中分配的位置不同:     </p>
</blockquote>
<ul>
<li>实例变量，随着对象的创建而产生，分配在堆空间中     </li>
<li>静态变量，随着类的加载而产生的，分配在方法区里</li>
</ul>
<p>静态变量的加载要早于对象的创建  </p>
<p>　　   静态变量         非静态变量（实例变量）</p>
<p>类       　可以              　不可以</p>
<p>对象     　可以             　 可以</p>
<p>使用static修饰方法:静态方法（随着类的加载而加载） </p>
<p>　　　静态方法         非静态方法（实例变量） </p>
<p>类     　  可以　　　　不可以 </p>
<p>对象  　   可以 　　　　可以 </p>
<p>静态方法内:可以调用静态属性或者静态方法,不可以调用非静态属性和非静态方法</p>
<p>非静态方法内:可以调用非静态属性或者非静态方法，可以调用静态属性和静态方法 </p>
<blockquote>
<p> 如何判断属性是否声明为:static? 是否需要类的多个对象类共享此属性；很多常量都声明为static 如何判断方法是否声明为:static?  操作静态变量的方法，工具类中的方法。（Math）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day14/" class="post-title-link" itemprop="url">day14</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:19:16" itemprop="dateModified" datetime="2020-02-12T14:19:16+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单例设计模式:</p>
<p>　饿汉式</p>
<p>　懒汉式</p>
<p>类的成员之四:代码块(或初始化块)    </p>
<ol>
<li><p>代码块的使用:用来初始化类,对象的信息     </p>
</li>
<li><p>代码块的分类:静态代码块 vs 非静态代码块    </p>
</li>
<li><p>静态代码块: </p>
<p>①可以提供输出语句 </p>
<p>②随着类的加载而执行,且只被加载一次  </p>
<p>③使用:初始化类的加载信息        </p>
<p>④内部只能调用当前类中静态的属性,方法。不能调用非静态的属性,方法</p>
<p>⑤如果定义了多个静态代码块，按照定义的先后顺序执行        </p>
<p>⑥静态代码块执行的顺序要早于非静态代码块    </p>
<p>非静态代码块:         </p>
</li>
</ol>
<p>　　　随着对象的创建而执行         </p>
<p>　　　每创建对象，都会执行一次               </p>
<p>　　　使用:初始化对象的属性</p>
<p>　　　内部可以调用静态的:属性,方法。也调用非静态的属性,方法</p>
<p>　　　如果定义了多个非静态代码块，按照定义的先后顺序执行</p>
<p>　　　非静态代码块执行的顺序要晚于静态代码块    </p>
<p>  4.给属性赋值的位置的先后顺序:        </p>
<p>　　①默认初始化     </p>
<p>　　②显示初始化 / 在代码块中初始化     </p>
<p>　　③构造器中初始化</p>
<p>　　④有了对象以后,通过“对象.属性”或“对象.方法”的方法,赋值</p>
<p>final关键字的使用: </p>
<ul>
<li><p>final:最终的  </p>
</li>
<li><p>final可以来修饰:变量,方法,类  </p>
</li>
<li><p>final修饰类:此类不可以被继承,比如String / StringBuffer类   </p>
</li>
<li><p>final修饰方法:此方法不能被重写，比如Object类的getClass </p>
</li>
<li><p>final修饰变量:此变量就是一个常量。比如:Math类中的PI  </p>
<p>使用final修饰属性,可以考虑的位置有：</p>
<p>　①显示初始化</p>
<p>　②代码块中</p>
<p>　③构造器中使用final修饰形参,在方法调用时,在方法调用时,传递实参,给变量赋值，一旦复制,方法内不可以  修饰常量的值      </p>
</li>
</ul>
<p>　　static final:所修饰的属性,称为全局常量</p>
<p>abstract关键字的使用: </p>
<ul>
<li><p>abstract :抽象的  </p>
</li>
<li><p>可用来修饰的结构:类,方法  </p>
</li>
<li><p>abstract修饰类:抽象类    </p>
<p>不可实例化</p>
<p>仍然存在构造器。构造器的作用:便于子类实例化时进行调用 </p>
<p>通常情况下,我们会提供抽象类的子类,让子类实例化,调用父类的结构。    　</p>
<p>抽象类中不一定有抽象方法;抽象方法所在的类，一定是抽象类</p>
</li>
<li><p>abstract修饰方法:抽象方法(没有方法体)    </p>
<p>如果子类重写了父类的所有抽象方法，则此子类可以实例化    </p>
<p>如果子类没有重写父类的所有抽象方法，则子类仍为抽象类  </p>
</li>
<li><p>前提:抽象性使用的前提是类的继承性</p>
</li>
</ul>
<blockquote>
<p>模板方法的设计模式</p>
</blockquote>
<p>接口的使用:</p>
<p>　　1.接口(interface) 是与类(class)并列的结构 </p>
<p>　　2.如何定义一个接口,使用interface关键字</p>
<p>　　3.接口中只能定义常量和抽象方法—–&gt;JDK7.0及以前版本(JDK8.0接口中引入默认方法,静态方法)</p>
<p>　　　常量的定义:public static final修饰</p>
<p>　　　抽象方法的定义: public abstract修饰 </p>
<p>　　4.接口中不能声明构造器！接口不可以直接实例化的 </p>
<p>　　5.类与接口之间的关系:实现(implements)关系,实现接口以后，就获取了接口中声明的结构:常量,抽象方法。</p>
<p>　　　格式:class SubClass extends SuperClass implements InterfaceA </p>
<p>　　6.类实现接口以后,要抹实现接口中的所有抽象方法,方可实例化          </p>
<p>　　　要抹当前类声明为抽象类(因为内部包含从接口中获取的抽象方法)</p>
<p>　　7.java规定:类可以实现多个接口—–&gt;一定程度上,解决了java类的单继承的局限性 </p>
<p>　　 8.java规定:接口与接口之间是继承关系,而且是可以多继承！</p>
<p>接口的使用:</p>
<p>　1.接口与具体的实现类之间存在多态性 </p>
<p>　2.如何提供接口的匿名实现类,如何去创建匿名对象</p>
<p>　3.接口,实际上可以理解为定义了一套相应的功能的规范,标椎</p>
<p>接口的应用:</p>
<ul>
<li>工厂模式</li>
<li>代理模式</li>
</ul>
<p>java8规范:  接口可以定义静态方法,默认方法</p>
<p>　　①知识点1:接口中定义的静态方法,只能通过接口进行调用</p>
<p>　　②知识点2:通过实现类的对象,调用接口中的默认方法</p>
<p>　　③知识点3:如果类实现的接口和父类中,定义了同名同参数的方法,那抹子类在没有重写此方法的情况下</p>
<p>　　　默认调用的是父类中声明的方法。—–“类优先”原则</p>
<p>　　④知识点4:如果实现类实现了多个接口,接口中定义了同名同参数的方法，那抹此时对于实现类来讲,会出现接口冲突问题。</p>
<p>　　解决方法:要求实现类必须重写接口中的方法。</p>
<p>　　⑤知识点5:如何在实现类的方法中调用接口中的默认方法</p>
<p>　　接口.super.方法()</p>
<p>类的成员之五:内部类(InnerClass)  </p>
<p> 1.定义:java语言在一个类A的内部再定义了一个类B。   </p>
<p>　　　将类B:称作内部类；类A:外部类  </p>
<p> 2.内部类,作为一个类:              </p>
<p>　　内部可以定义属性,方法,构造器等            </p>
<p>　　可以被final修饰            </p>
<p>　　可以被abstract修饰       </p>
<p>　　　　作为外部类的一个成员:          </p>
<p>　　可以被4种不同的权限修饰            </p>
<p>　　 可以被static修饰              </p>
<p>　　可以调用外部类的结构:属性,方法等   </p>
<p>  3.内部类的分类:成员内部类（静态的;非静态的）  vs 局部内部类  </p>
<p>  4.需要掌握的知识点:  </p>
<p>　　4.1 如何创建成员内部类的对象？  </p>
<p>　　4.2 如何调用外部类的结构？ </p>
<p>　　4.3 关于局部内部类在开发中的体现</p>
<p>部内部类的方法中调用局部内部类所在方法中定义的局部变量，要求此局部变量声明为final的。</p>
<p>在java7及以前的版本中，需要显示的声明为final。</p>
<p>在java中可以省略final的声明</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day15/" class="post-title-link" itemprop="url">day15</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:08:03" itemprop="dateModified" datetime="2020-02-12T14:08:03+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>异常的体系结构:    </p>
<p>　　java.lang.Throwable        </p>
<p>　　—-Error:错误。不编写针对代码进行处理 </p>
<p>　　　—–StackOverflowError</p>
<p>　　　—–OOM   </p>
<p>　　—-Exception:异常:可以编写针对性的代码进行处理      </p>
<p>　　　—–编译时异常:编译时就不通过的异常,报出来的异常  </p>
<p>　　　—–运行时异常(RuntimeException):编译通过,运行时不通过,报出来的异常      </p>
<p>　　　　| —–NullPointerException:空指针异常                </p>
<p>　　　　|—–ArrayIndexOutOfBoundsException:数组角标越界异常  </p>
<p>　　　　 |—–ClassCastException:类型转换异常 </p>
<p>　　　　 |—–NumberFormatException:数值格式化异常 </p>
<p>　　　　 |—–InputMismatchException:输入的类型不匹配 </p>
<p>　　　　 |—–ArithmeticException:算术异常 </p>
<p>　　　　 |———-。。。  </p>
<p>  面试题:常见的异常?并举例说明</p>
<p>如何处理异常(Exception)？ </p>
<p>　java提供了异常处理的:抓抛模型 </p>
<p>　1.过程一:“抛”:程序在正常的执行过程中,一旦出现异常，就会在相应的代码处生成相应的异常类的对象。</p>
<p>　　　　　▶并将对象抛出,异常出现位置后面的代码就不再执行。    </p>
<p>　　　　　▶异常出现位置的后面的代码不再执行  </p>
<p>　　　　　异常对象产生的方式:①自动抛出 ②手动抛出(在方法内,使用throw + 异常类的对象)</p>
<p>​    2.过程二:“抓”:看出是异常的处理的方法:try catch finally;throws   </p>
<p>​        try{  </p>
<p>​             //可能出现异常的代码   }catch(Exception el){ </p>
<p>​             //处理异常的方式1   }catch(Exception e2){   </p>
<p>​             //处理异常的方式2   }…   </p>
<p>​       finally{     //一定要被执行的操作   }  </p>
<p>​      、</p>
<p>说明:    </p>
<ul>
<li><p>finally是可选的     </p>
</li>
<li><p>在执行try中的语句是时,一旦出现异常,就会抛出相应异常的对象</p>
<p>此对象会在如下的catch中进行匹配,一旦匹配成功,就进入相应的</p>
</li>
</ul>
<p>​        catch的代码块中进行相应的异常处理,一旦处理完成,就跳出整个   </p>
<p>​        try-catch结构，不再执行其后的catch语句。  </p>
<ul>
<li><p>多个catch语句中的异常类型说明:子类异常必须声明在父类异常的上面, </p>
<p>否则编译不通过。如果多个异常类型没有子父类关系,则没有顺序要求。     </p>
</li>
</ul>
<ul>
<li><p>执行完catch语句以后,如果其结构还有操作,则可以正常执行。    </p>
</li>
<li><p>在try中定义的变量,其作用于仅限于try声明的一对{},出了此{}，不可被调用 </p>
</li>
<li><p>catch中常见的异常处理方：</p>
<p>　①getMessage()返回一个String变量       </p>
<p>　②printStackTrace();打印异常产生的堆栈信息     总结:运行时异常</p>
</li>
<li><p>try-catch-finally  结构可以嵌套</p>
</li>
</ul>
<p>关于try-catch-finally结构中finally的使用:  </p>
<p>　1.可选的</p>
<p>　2.即使在catch中出现异常,try中有return；catch中有return；三种情况,finally中的代码也一定会执行！   </p>
<p>　 3.开发中的应用:IO流资源,网络Socket，数据库连接等,JVM不会自动进行资源的关闭和垃圾的回收,    </p>
<p>　　需要我们手动去释放资源。所以此操作必须声明在finally中。</p>
<p>异常的的处理方式二:throws + 异常类型</p>
<p>　　 格式:在方法的声明后,使用 “throws + 异常类型 ”,表示:一旦方法执行过程中,出现异常将此异常的对象抛出。 </p>
<p>　　1.上述出现的异常对象，会抛给方法的调用者。比如method1()在method()2   </p>
<p>　　　调用,如果method()1出现异常,则此异常抛给了method()2。  </p>
<p>　　2.体会try-catch-finally:真正处理异常,一旦处理完,就不会影响后续代码执行 </p>
<p>　　　throws:并没有真正的处理异常。   </p>
<p>　　3.总结:开发中如何选择使用哪种方式处理?    </p>
<ul>
<li>如果父类被重写的方法没有throws的方式处理异常,则子类重写的方法也不能用 throws的  方式去处理异常,只能用try-catch-finally。 </li>
<li>在一个方法a中,调用了另外的3个方法,此3个方法通常是递进关系的。一般情况下, 此3个方法中如果出现异常,通常使用throws的方式处理异常。然后统一在方法a中 使用try-catch-finally进行处理。</li>
</ul>
<p>规定:子类重写的方法抛出的异常类型不能大于父类被重写的方法抛出的异常</p>
<p>包装类Integer (parseInt) 将字符串转成整数</p>
<p>注解：代码里的特殊标记</p>
<p>　OVerride 重写</p>
<p>　Deprecated 过时   </p>
<p>　SuppressWarnings 抑制编译器警告</p>
<p>元注解：解释说明当前注解的</p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day16/" class="post-title-link" itemprop="url">day16</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:20:56" itemprop="dateModified" datetime="2020-02-20T11:20:56+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.java中的容器–在内存层面,对数据进行统一的存储和管理:数组 ；java集合</p>
<p>​    扩展:数据的持久化:文件(.jpg;mp3); xml ; 数据库</p>
<p>2.数组在内存存储方面的特点:</p>
<p>　　①数组初始化以后,长度就确定了                </p>
<p>　　②数组类型声明后，就决定了进行元素初始化的类型   </p>
<p>弊端:数组初始化以后,长度就不可变了</p>
<p>　　数组中提供的属性和方法很少,不便于进行添加,删除,插入等操作            </p>
<p>　　数组存储的数据是有序的,可以重复的—–&gt;存储数据的特点单一    </p>
<p>　　String[] arr = new String[10]      </p>
<p>　　Object[]  </p>
<p>3.集合框架     </p>
<p>　java.util.Collection:单列数据</p>
<p>　|——-List子接口:存储有序的,可重复的数据—-&gt;“动态”数组</p>
<p>　　　|—–ArrayList:作为List的主要实现类,线程不安全的,效率高；底层使用数组</p>
<p>　　　|—–LinkedList:对于频繁的插入,删除操作，我们建议使用此类,效率高；底层使用双向链表实现       </p>
<p>　　　|—–Vector:List的古老实现类,线程安全的,效率低；底层使用数组实现</p>
<p>​     [面试题] ArrayList,LinkList,Vector区别?</p>
<p>　　　　共同点:ArrayList,LinkList,Vector都是List接口的实现类,存储的数据都是有序的,可重复的</p>
<p>　　　　　　　区别:如上</p>
<p>　　　　　　　List list = new ArrayList();</p>
<p>　　　　　　　list.add(..);</p>
<p>　　　　　　　…</p>
<p>　　　　　　　一旦添加元素超出底层数组的长度,就需要扩容,默认扩容需要为原来的1.5倍，同时              </p>
<p>　　　　　　　需要将原有数组中的元素复制到新的数组中。</p>
<p>实际情况:需要存储80个数据到ArrayList中,建议:List list = new ArrayList(85);            </p>
<p>　　　|——-Set子接口:存储无序的,不可重复的数据—-&gt;高中讲的“集合”</p>
<p>　　　　　　|—- HashSet 主要实现类,底层实现:HashSet底层使用了HashMap</p>
<p>　　　　　　|—- LinkedHashSet 是HashSet的子类,可以按照添加的顺序实现遍历     </p>
<p>　　　　　　　　(原因:在HashSet底层存储上的基础上,额外使用了一对指针,能够记录此Node元素的</p>
<p>　　　　　　　　 上一个元素和下一个元素) —&gt; 对于频繁的遍历，效率高</p>
<p>　　　　　　|—- TreeSet : 可以按照添加元素的指定属性的大小实现遍历。底层实现：红黑树</p>
<p>　　　　　　 TreeSet的使用</p>
<p>　　　　　　　　　1.向TreeSet中添加的元素必须是同一个类创建的对象</p>
<p>　　　　　　　　　2.TreeSet排序的方式:①自然排序 ②定制排序</p>
<p>　　　　　　　　　3.自然排序: </p>
<p>　　　　　　　　　　　①要求添加的元素所在的类实现Compare接口 </p>
<p>　　　　　　　　　　　②重写接口中的CompareTo(Object obj)—&gt;指明排序的规则</p>
<p>　　　　　　　　　　　　如果此方法返回值0，则要新添加的元素添加不成功</p>
<p>　　　　　　　　　　　③向TreeSet添加此实现类的对象即可</p>
<p>　　　　　　　　　定制排序：</p>
<p>　　　　　　　　　　　TreeSet的定制排序:     </p>
<p>　　　　　　　　　　　　1.提供Comparator接口匿名实现类的对象 </p>
<p>　　　　　　　　　　　　2.重写其中的compare(Object o1,Object o2),指明排序的规则 </p>
<p>　　　　　　　　　　　　3.将此实现类的对象作为参数传递到TreeSet的构造器中   </p>
<p>　　　　　　　　　　　　4.向TreeSet的对象中添加compare()方法中判断类的对象</p>
<blockquote>
<p>　总结:   元素是否能add成功,是否能remove,是否contains…..</p>
<p>　　　　都依赖于compareTo或者compare方法   与元素所在类的hasCode/equals无关</p>
</blockquote>
<p>set作为Collection的子接口,没有定义额外的方法set:存储无序的,不可重复的元素  </p>
<ol>
<li><p>无序性！= 随机性.添加的元素,需要计算哈希值,此哈希值决定了在底层储存的位置,从存储位置上看,  是无序的</p>
</li>
<li><p>不可重复性:保证set集合中不同对象使用对象所属类的equals()方法判断的话,一定返回false。</p>
</li>
<li><p>如何向Set中添加一个元素?哈希算法   </p>
</li>
</ol>
<p>　　　向Set中添加元素a,首先通过hasCode()，计算元素的哈希值,此哈希值就决定了此元素在Set底层</p>
<p>　　　存储的位置，如果此存储位置上没有元素,则此元素a添加成功 ，如果此存储的位置上有元素b,则</p>
<p>　　　调用元素a所在类的equals（）方法.将元素b作为参数传递过去,如果返回值为true，则表示元素</p>
<p>　　　a和元素b相同，添加不成功，如果返回值为false,则认为元素a和元素b不相同,此时元素b可以添</p>
<p>　　　加成功的.元素a和元素b使用链表存储（jdk7.0:a指向b；JDK8.0:b指向a）  </p>
<p>　4.向Set中添加的元素,要求其所在的类要重写两个方法:  equals() 和 hashCode() </p>
<p>　5.必须要求添加的元素所在的类中重写equals() 和 hashCode（）保持一致</p>
<p>Map:存储的是双列数据：key-value </p>
<p>　1.所有的key构成的是集合是set:无序的,不可重复的 </p>
<p>　2.所有value构成的是集合Collection:无序的,可以重复的 </p>
<p>　3.一个key-value构成一个Entry</p>
<p>　4.所有的Entry构成的集合是Set:无序的,不可重复的</p>
<p>　HashSet的底层使用HashMap存储的</p>
<p>　HashMap的所有key构成的集合是HashSet</p>
<p>|—-HashMap:Map的主要实现类,线程不安全,效率高；可以存储null的key和value</p>
<p>　　 (存储结构：Jdk7.0数组+链表,Jdk8.0数组+红黑树) </p>
<p>　　|—-LinkedHashMap:HashMap的子类,可以按照添加的顺序遍历,对于频繁的遍历效率</p>
<p>　　(在HashMap存储的基础上,使用了一对指针,来记录添加元素的顺序)</p>
<p>|—-TreeMap：可以按照key的指定的属性进行排序,遍历,底层实现:红黑树</p>
<p>|—-Hashtable：Map的古老实现类:线程安全,效率低;不可以存储null的key和value </p>
<p>　　　|—-Properties:Hashtable的子类，常常用来处理属性文件，其key和value都是String类型的</p>
<p>Map常用方法：</p>
<p>　添加:put(Object key,Object value)</p>
<p>　修改:put(Object key,Object value)</p>
<p>　删除:Object remove(Object obj)</p>
<p>　长度:size()</p>
<p>　清空数据:clear()</p>
<p>　是否为空isEmpty()</p>
<p>1.遍历所有的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Set keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">  Iterator iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123; </span><br><span class="line"></span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​     2.遍历所有的value</p>
<p>​       </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = map.values();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(Object obj:coll)&#123;  </span><br><span class="line"></span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>​    3.遍历所有的key-value</p>
<p>​          1.方式一：</p>
<p>​         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set keySet1 = map.keySet();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(Object key:keySet1)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(key+<span class="string">"----&gt;"</span>+map.get(key));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​         2.方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object o:entrySet)&#123; </span><br><span class="line"></span><br><span class="line">              Map.Entry entry = (Map.Entry)o;</span><br><span class="line"></span><br><span class="line">              System.out.println(entry.getKey()+<span class="string">"********"</span>+entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>Map常用方法：</p>
<ul>
<li>添加:put(Object key,Object value)</li>
<li>修改:put(Object key,Object value)</li>
<li>删除:Object remove(Object obj)</li>
<li>长度:size()</li>
<li>清空数据:clear()</li>
<li>是否为空isEmpty()</li>
</ul>
<p> 总结:</p>
<p>　　增：put(Object key,Object value)</p>
<p>　　删：Object remove(Object obj)</p>
<p>　　改：put(Object key,Object value)</p>
<p>　　查：get(Object key)</p>
<p>　　长度:size()</p>
<p>　　遍历:keySet() / values() / entrySet()List (index—&gt;数据)/ Set（很少用）/ Map（key –&gt; 数据）</p>
<p>   说明：1.向List中添加自定义类的对象的话,要求此定义类要重写equals()方法</p>
<p>　　　　2.补充:数据结构解决两个问题:</p>
<p>　　　　　　　1.数据之间逻辑关系：一对一，一对多，多对多…</p>
<p>　　　　　　　2.数据的存储结构:①顺序存储:一维数组 ②链式存储</p>
<p> 4.测试Collection中的常用方法</p>
<p>​       ①size（）返回集合中存储的元素的个数</p>
<p>​       ②add(Object obj) 将obj添加到当前的集合中</p>
<p>​       ③addAll(Collection coll) 将coll1集合中的所有元素添加到当前集合中</p>
<p>​       ④isEmpty() 判断当前集合是否为空</p>
<p>​       ⑤clear 清除当前集合</p>
<p>​       ⑥contains(Object obj) 判断当前集合中是否包含obj：调用了obj所在类的equals（）方法</p>
<p>​       ⑦containsAll(collection coll)    当前集合是否包含coll中的所有元素</p>
<p>​       ⑧remove(Object obj):从当前集合中移除obj元素.仍然需要obj所在类的equals的方法</p>
<p>​       ⑨removeAll(Collection coll):差集:从当前集合中移除coll集合中的元素</p>
<p>​       ⑩retainAll(Collection coll)：交集：获取当前集合和coll共有的元素</p>
<p>​       ⑪equals(Object obj):比较当前对象和obj是否相等。</p>
<p>​       ⑫hashCode():获取当前对象的哈希值</p>
<p>​       ⑬toArray()：将集合转换成数组:Object[]</p>
<p>​       ⑭toArrays(T[] arr):略</p>
<p>​       ⑮Iterator():集合元素的遍历。迭代器</p>
<p>​          hasNext():判断是否还有下一个元素</p>
<p>​          next():①指针下移 ②将指针下移以后集合位置上的元素返回</p>
<p>5.规定：如果集合中存储自定义类的对象，要求自定义重写equals方法</p>
<p>6.集合：很常用。</p>
<p>　　掌握点：层次一：选择合适的集合类实现数据的保存,调用其内部的相关方法</p>
<p>　　　　　　层次二:不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</p>
<p> 集合的遍历:</p>
<p>　方式一：使用Iterator实现</p>
<p>　方式二：增强for循环(foreach循环)</p>
<p>　　　　　for(集合元素的类型 局部变量 : 集合引用)</p>
<p>List:</p>
<p>在Collection的基础上，新增的方法：</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 </li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置.如果不存在，返回-1.</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置.如果不存在，返回-1.</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为eleList</li>
<li>subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合    </li>
<li>substring(int from ,int to) /  read(int from,int length)  </li>
</ul>
<p>​      总结：List中的常用方法：</p>
<p>　　　增：add(Object obj)</p>
<p>　　　删：remove(Object obj) / remove(int index)  </p>
<p>　　　改：set(int index, Object ele)</p>
<p>　　　查：get(int index)</p>
<p>　　　插：add(int index, Object ele)</p>
<p>　　　遍历：iterator();增强for;for   </p>
<p>　　　长度：size()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day19/" class="post-title-link" itemprop="url">day19</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:33:56" itemprop="dateModified" datetime="2020-02-20T11:33:56+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  一、流的分类</p>
<p>　1.流的流向：输入流、输出流</p>
<p>　2.流中数据单位：字节流、字符流</p>
<p>　3.流的角色不同：节点流、处理流</p>
<p>  二、 抽象基类                          节点流(或文件流)                                       缓冲流(处理流的一种)：提高数据读写效率</p>
<p>​          InputStream                   FileInputStream(read(byte[]))                 BufferedInputStream(read(byte[])</p>
<p>​          OutputStream               FileOutputStream(write(byte[],0,len))  BufferedOutputStream(write(byte[],0,len)</p>
<p>​         Readed                            FileReader(read(char[]))                          BufferedReader(read(char[]) / readLine())</p>
<p>​         Writer                              FileWriter(write(char[],0,len))                  BufferedWriter(write(char[],0,len)</p>
<p>从指定文件中读取数据到控制台上</p>
<p>　1.要去读的文件一定要存在的,否则报FileNotFoundException</p>
<p>　2.因为需要保证流的资源关闭,所以异常的处理需要使用try-catch-finally</p>
<p>字节流：</p>
<p>　输入流:FileInputStream</p>
<p>　1.创建一个文件,指明读取数据的来源</p>
<p>　2.将file对象作为参数传递到流的构造器中,创建一个字节的输入流:FileInputStream</p>
<p>　3.read():读取文件中的下一个字节。如果到达文件末尾的话,返回-1</p>
<p>　4.关闭资源</p>
<p> 输出流:FileOutputStream</p>
<p>　1.造文件</p>
<p>　2.造流:输出流</p>
<p>　3.写出数据  getBytes()  字符串—&gt;字节数组</p>
<p>　4.关闭资源</p>
<p>　　* 如果输出的文件不存在,则在输出执行的过程中,自动创建此文件<br>　　* 如果输出的文件存在：如果使用构造器：FileOutputStream(file)是对已存在的文件的覆盖, </p>
<p>​                                              如果使用构造器:FileOutputStream(file,true)是在已有文件内容的基础上,继续写入内容</p>
<p>字符流</p>
<p>　 FileReader 和 FileWriter的使用：只能用来处理文本文件的。</p>
<p>　FileInputStream 和  FileOutputStream:适合用来处理非文本文件：.avi , .mp3, .jpg, .doc</p>
<p>   1.造文件</p>
<p>   2.造流：字符的输入流、字符的输出流</p>
<p>   3.读取数据并写出</p>
<p>   4.关闭资源</p>
<p>缓冲流的使用。</p>
<p>　1.缓冲流是处理流的一种</p>
<p>　2.作用：提高数据的读写效率</p>
<p>　3.类： 处理非文本文件：</p>
<p>　　　BufferedInputStream</p>
<p>　　　BufferedOutputStream</p>
<p>　　　　处理文本文件：</p>
<p>　　　BufferedReader</p>
<p>　　　BufferedWriter  —&gt;readLine 读取一行</p>
<p>　　　　　　　　　　　—&gt;newLine 开始新的一行</p>
<p>理流之二：转换流</p>
<p>　1.转化流的作用：能够实现字节流与字符流之间的转换</p>
<p>　2.涉及到的流：</p>
<p>　　　InputStreamReader:实现字节的输入流转换为字符的输入流</p>
<p>　　　OutputStreamWriter:实现字符的输出流转换为字节的输出流</p>
<p>　　编码的过程：字符串、字符数组—&gt;字节数组</p>
<p>　　解码的过程：字节数组—-&gt;字符串、字符数组</p>
<p> 3.常见的编码集：</p>
<p>　ASCII：美国标准信息交换码，用一个字节的7位可以表示。</p>
<p>　ISO8859-1：拉丁码表。欧洲码表.  用一个字节的8位表示。</p>
<p>　GB2312：中国的中文编码表。</p>
<p>　GBK：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p>　Unicode：国际标准码，融合了多种文字。 所有文字都用两个字节来表示,Java语言使用的就是unicode</p>
<p>　UTF-8：最多用三个字节来表示一个字符</p>
<p>处理流之三：标准的输入、输出流 </p>
<p>　System.in:标准的输入流，默认从键盘输入 </p>
<p>　<em>System.out:标准的输出流，默认从显示屏输出</em> </p>
<p>　 System.setIn():重新指定输入的位置 </p>
<p>　System.setOut():重新指定输出的位置</p>
<p>处理流之四：打印流 PrintStream 和 PrintWriter</p>
<p>处理流之五：数据流 DataInputStream 和 DataOutpuStream</p>
<p>处理流之六：对象流</p>
<p>　1.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中， 也能把对象从数据源中还原回来。</p>
<p>　2.涉及到的流：ObjectInputStream 和 ObjectOutputStream</p>
<p>　3.对象序列化机制：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象.</p>
<p>提供一个自定义类，实现序列化机制。</p>
<p>　要求：1.自定义类实现Serializable接口</p>
<p>　　　　2.需要给当前的类声明全局的常量：serialVersionUID</p>
<p>　　　　3.要求类的属性也是可序列化的。 (默认情况下：String、基本数据类型都是可序列化的)</p>
<p>　　　　注意：不能序列化static和transient修饰的成员变量</p>
<p>RandomAccessFile的使用：随机存取文件流</p>
<p>　1.RandomAccessFile在java.io包下声明，直接继承于Object类</p>
<p>　2.既可以作为输入流，又可以作为输出流。</p>
<p>　3.如果输出到的文件不存在，则会在输出的过程中，自动创建此文件 。 如果输出到的文件存在，</p>
<p>　　则不是对文件的覆盖，而是对文件内容的覆盖。（默认从头覆盖）</p>
<p>　4.实现数据的“插入” </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day17/" class="post-title-link" itemprop="url">day17</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:33:11" itemprop="dateModified" datetime="2020-02-20T11:33:11+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>731</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Collections:用来操作集合框架(Collection / Map)的工具类</p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object  </li>
<li>object min(Collection)</li>
<li>Object min(Collection，Comparator)</li>
<li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li>
</ul>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中</li>
</ul>
<p>　　List dest = Arrays.asList(new Object[list.size()]);</p>
<p>　　Collections.copy(dest, list);</p>
<p>　　System.out.println(dest);</p>
<ul>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li>
</ul>
<p>  list:线程不安全的。</p>
<p>  List newList = Collections.synchronizedList(list);</p>
<p>  newList:线程安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day18/" class="post-title-link" itemprop="url">day18</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:33:44" itemprop="dateModified" datetime="2020-02-12T13:33:44+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>泛型的应用:</p>
<p>　1.JDK 5.0 新增的特性</p>
<p>　2.主要内容：</p>
<p>　　2.1 在集合中使用泛型</p>
<p>　　2.2 如何自定义泛型类,泛型接口,泛型方法(理解)</p>
<p>　　2.3 泛型在继承上的体现(掌握)</p>
<p>　　2.4 通配符的使用（掌握）</p>
<p>在集合中使用泛型的情况</p>
<p>在集合中使用泛型</p>
<p>　1.在Java的集合中,声明的接口或者类已经声明泛型</p>
<p>　2.我们在实例化接口时,可以指明泛型的类型</p>
<p>　3.不能使用基本数据类型,需要使用对应的包装类替换</p>
<p>　4.一旦创建对象时,使用了泛型,则通过对象调用方法,属性时,如果方法或属性使用了类的泛型,   则此时泛型类型就是对象实例化时候的类型</p>
<p>　5.如果实例化时候,不指明泛型参数,则默认是Object类型</p>
<p>自定义泛型类:</p>
<p>　仿照List去创建</p>
<p>　1.在类的声明后面,指明泛型参数,参数通常使用:T E K V</p>
<p>　2.在类的属性,方法,构造器中,可以使用类的泛型参数</p>
<ul>
<li>使用了类的泛型参数的方法,不能声明为static的</li>
<li>不能在try-catch中使用泛型参数表示异常类型</li>
</ul>
<p>关于自定义泛型类,泛型接口,泛型方法的使用</p>
<p>　自定义泛型类的使用:</p>
<p>　　1.在实例化泛型类时,可以指明泛型的参数类型</p>
<p>　　2.提供泛型类的子类时,可以指明泛型的参数类型.比如:SubOrder1类</p>
<p>泛型在继承上的体现</p>
<p>　　1.如果A类是B类的父类,则List<A>与List<B>是没有子父类的关系的  </B></A></p>
<p>　　　扩展：则G<A> 和 G<B>没有子父类关系！</B></A></p>
<p>　　2.如果A类是B类的父类,则A<G> 是 B<G>的父类</G></G></p>
<p>通配符: ? 的使用：</p>
<p>　　A类是B的父类,则G<A> 和 G<B> 的公共父类为G&lt;?&gt;</B></A></p>
<p>　关于数据的读写问题</p>
<p>　写入数据:不允许向使用通匹配符的集合中写入数据，除非可以写入null</p>
<p>　读取数据：可以从使用了通配符的集合中读取数据。读取的数据的类型默认是Object</p>
<p>有限制条件的通配符的使用? </p>
<p>？  extends A:举例:List&lt;? extends A&gt; 可以作为List<B>或者List<A>的父类,其中B类是A类的子类?</A></B></p>
<p>？   super A: 举例:List&lt;? super A&gt; 可以作为List<B>或List<A>的父类,其中B类是A类的父类</A></B></p>
<p>File类：</p>
<p>　 1.java.io包下定义的</p>
<p>　 2.一个File类的对象，既可以表示一个文件(.txt,.mp3,.avi,mp4,.doc)，也可以表示一个文件目录。</p>
<p>　 3.File类中只涉及到文件或文件目录的新建、删除、长度、修改时间、重命名等操作。没有涉及到对文件内容的修改。如果需要对文件内容进行修改的话，需要使用流。</p>
<p>　 4.File类的对象常常作为流的构造器的参数出现。</p>
<p>　 5.File类的对象代表着流资源读取或写入到的文件。</p>
<p>  File类的实例化 </p>
<p>  　 绝对路径：包含盘符在内的文件或文件目录的完整路径 </p>
<p>  　 相对路径：相较于某一层文件路径来讲。比如：在Eclipse中的相对路径是相较于当前工程的。 </p>
<p>   两个构造器： </p>
<p>　　File(String pathname) </p>
<p>　　File(String parent,String pathname)</p>
<p>获取文件名:</p>
<p>getName()</p>
<p>getPath()</p>
<p>getAbsoluteFile()</p>
<p>getAbsolutePath()</p>
<p>getParent()</p>
<p>toPath()</p>
<p>renameTo(File newName)</p>
<p>   file1.renameTo(File file2):file1重命名为file2是否成功</p>
<p>   如果希望返回值为true.则必须：file1对应的物理磁盘上的文件需要存在，且file2对应的物理磁盘上的文件不存在。</p>
<p>文件检测:</p>
<p>   exists()</p>
<p>   canWrite()</p>
<p>   canRead()</p>
<p>   isFile()</p>
<p>   isDirectory()</p>
<p>获取文件常规信息:</p>
<p>   lastModified()</p>
<p>   length()</p>
<p>  操作文件相关的：</p>
<p>​    createNewFile()：在物理磁盘上创建指定路径的文件</p>
<p>​    delete():删除物理磁盘上指定路径的文件</p>
<p>  操作文件目录相关的：</p>
<p>​    mkdir()/mkdirs():如果要创建的文件目录的上层目录存在，则二者没有区别。</p>
<p>​    如果要创建的文件目录的上层目录不存在，mkdir()创建不成功，mkdirs()创建成功。</p>
<p>   delete()：删除物理磁盘上指定路径的文件目录list()listFiles()</p>
<p>list() / listFiles()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day20/" class="post-title-link" itemprop="url">day20</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:19:01" itemprop="dateModified" datetime="2020-02-12T14:19:01+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk 7.0 时，引入了 Path、Paths、Files三个类。</p>
<p>　1.此三个类声明在：java.nio.file包下。</p>
<p>　2.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关</p>
<p>　3.如何实例化Path:使用Paths. </p>
<p>　　static Path get(String first, String … more) : 用于将多个字符串串连成路径</p>
<p>　　static Path get(URI uri): 返回指定uri对应的Path路径 </p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path:"></a>Path:</h2><p>   String toString() ： 返回调用 Path 对象的字符串表示形式</p>
<p>   boolean startsWith(String path) : 判断是否以 path 路径开始</p>
<p>   boolean endsWith(String path) : 判断是否以 path 路径结束</p>
<p>   boolean isAbsolute() : 判断是否是绝对路径</p>
<p>   Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</p>
<p>   Path getRoot() ：返回调用 Path 对象的根路径</p>
<p>​       Path getFileName() : 返回与调用 Path 对象关联的文件名</p>
<p>​       int getNameCount() : 返回Path 根目录后面元素的数量(层数)</p>
<p>​       Path getName(int idx) : 返回指定索引位置 idx 的路径名称</p>
<p>​       Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</p>
<p>​       File toFile(): 将Path转化为File类的对象</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制      </p>
<p>​    &gt;要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</p>
<p>​      Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING); 当已存在时做覆盖</p>
<p>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录      </p>
<p>​      要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</p>
<p>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件      </p>
<p>​      要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</p>
<p>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</p>
<p>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</p>
<p>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置      </p>
<p>   要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</p>
<p>   Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</p>
<p>long size(Path path) : 返回 path 指定文件的大小</p>
<p>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</p>
<p>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</p>
<p>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</p>
<p>boolean isHidden(Path path) : 判断是否是隐藏文件</p>
<p>​    &gt;要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常</p>
<p>boolean isReadable(Path path) : 判断文件是否可读</p>
<p>boolean isWritable(Path path) : 判断文件是否可写</p>
<p>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</p>
<p>StandardOpenOption.READ:表示对应的Channel是可读的。 </p>
<p>StandardOpenOption.WRITE：表示对应的Channel是可写的。</p>
<p>StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略 StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常</p>
<p>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</p>
<p>DirectoryStream<Path>  newDirectoryStream(Path path) : 打开 path 指定的目录</Path></p>
<p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</p>
<p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</p>
<p>jdk 7 提供基于try-catch的自动资源管理</p>
<p>　能够实现资源的自动关闭，需要满足：</p>
<p>　　1.可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</p>
<p>　　2.需要关闭的资源，必须实现了 AutoCloseable 接口或其子接口 Closeable目的：不需要再使用finally，显式的关闭资源了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day2/" class="post-title-link" itemprop="url">day2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 15:01:06" itemprop="dateModified" datetime="2020-02-12T15:01:06+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>赋值运算符 = </p>
<p>支持链式赋值 a  = b = 99</p>
<p>复合赋值运算符 (+=  , -=  , /= , *=)</p>
<p>short a = 10;</p>
<p>a += 2  与 a = a +2 相似，有区别的</p>
<p>a += 2     相当于a自增,不会改变本身变量数据类型</p>
<p>a = a +2  因为整型常量默认是int，所以a+2，自动提升数据类型为int,会报错</p>
<p>真正开发中，如果希望变量自增1：</p>
<p> 方式1： i = i + 1</p>
<p> 方式2： i += 1</p>
<p> 方式3： i++   (推荐)</p>
<p>真正开发中，如果希望变量自增2：</p>
<p> 方式1： i = i + 2</p>
<p> 方式2： i += 2  (推荐)</p>
<p>比较运算符： ==    !=    &gt;  &lt;   &gt;=  &lt;=  instanceof</p>
<p>比较运算符的结果都是布尔类型（boolean）</p>
<p>逻辑运算符：运算符操作的是boolean型变量，运算结果也是boolean类型</p>
<p>&amp;逻辑与运算符     &amp;&amp; 短路与</p>
<p>|逻辑或运算符      ||   短路或    </p>
<p>！逻辑非运算符     ^    逻辑异或</p>
<p>&amp;和&amp;&amp;运算结果相同，如果符号左边是true,两个运算符都要执行右边的运算</p>
<p>​                                       如果符号左边是false,&amp;仍然要执行右边的，&amp;&amp;不在执                            </p>
<p>​                                        行符号右边的</p>
<p>|和||运算结果相同，  如果符号左边是true,   |仍然要执行右边的，||不在执                            </p>
<p>​                                        行符号右边的</p>
<p>​                                        如果符号左边是false,两个运算符都要执行右边的运算</p>
<p>​                                         </p>
<p>位运算符：操作的都是数值型变量</p>
<p>&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;(无符号右移)  &amp;  |  ^  ~</p>
<p>&lt;&lt; 规律：在一定范围内，每左移一位，相当于数值*2，过犹不及(截断是让数值变的更小)</p>
<p>。&gt;&gt; 规律：在一定范围内，每右移一位，相当于数值/2，过犹不及。</p>
<p>。&gt;&gt;&gt;:右移以后最高位拿0补</p>
<p>三元运算符：（条件表达式）？表达式1：表达式2</p>
<p>​                           表达式1和表达式2的数据类型要一致（满足自动类型提升也可以）</p>
<p>三元运算符一定可以转换为if else,反之不成立</p>
<p>顺序结构：</p>
<p>前向引用</p>
<p>分支结构：</p>
<p>if(条件表达式){</p>
<p>​    执行代码块</p>
<p>}</p>
<p>if(条件表达式){</p>
<p>​    执行代码块1</p>
<p>}</p>
<p>else{</p>
<p>​     执行代码块2</p>
<p>}</p>
<p>if(条件表达式1){</p>
<p>​    执行代码块1</p>
<p>}</p>
<p>else if(条件表达式2){</p>
<p>​     执行代码块2</p>
<p>}</p>
<p>else{</p>
<p>​         执行代码快n</p>
<p>}</p>
<p>1.else：结构可选的</p>
<p>2.如果两个条件表达式没有公共的交集，此时两个else if结构，可以交换结构</p>
<p>   .如果两个条件表达式有公共的交集，要求范围小的条件表达式放在条件表达式的上面，</p>
<p>​    此时两个条件表达式才有可能都被执行到</p>
<blockquote>
<p> 从键盘获取数据</p>
</blockquote>
<ul>
<li><p>导包</p>
<p>import java.util.Scanner;</p>
</li>
<li><p>实例化Scanner</p>
</li>
<li><p>调用相关方法，获取不同类型的变量</p>
<p>next 字符串</p>
<p>nextInt 整数</p>
<p>nextDouble  double</p>
<p>nextFloat       float  </p>
<p>nextBoolean  布尔类型</p>
<p>Scanner类中没有从键盘获取char的方法</p>
<p>用户输入的变量类型与调用的方法类型需要一致，否则，报inputMismatchException</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day22/" class="post-title-link" itemprop="url">day22</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:35:08" itemprop="dateModified" datetime="2020-02-20T11:35:08+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、继承Thread的方式</p>
<p>　　1.提供一个继承于Thread类的子类</p>
<p>　　2.重写Thread类的run():将创建的线程要执行的操作，声明在run()中。</p>
<p>　　3.实例化Thread子类</p>
<p>　　4.调用子类对象的start() </p>
<p>Thread类的常用方法的测试</p>
<p> 　　1.run():Thread的子类一定要重写的方法。将此分线程要执行的操作，声明在run()中</p>
<p>　 　2.start():要想启动一个分线程，就需要调用start():①启动线程②调用线程的run()</p>
<p>　 　3.currentThread():静态方法，获取当前的线程</p>
<p>　 　4.getName():获取当前线程的名字</p>
<p>　 　5.setName(String name)：设置当前线程的名字</p>
<p>　 　6.yield():当前线程调用此方法，释放CPU的执行权</p>
<p>　 　7.join():在线程a中调用线程b的join()方法:只用当线程b执行结束以后，线程a结束阻塞状态，继续执行。</p>
<p>　　 8.sleep(long millitimes):让当前的线程睡眠millitimes毫秒</p>
<p>　 　9.isAlive():判断当前线程是否存活 </p>
<p>　　10.线程的优先级：</p>
<p>　　　　 MAX_PRIORITY：10 </p>
<p>　　　　NORM_PRIORITY：5 —默认优先级</p>
<p>　　　　MIN_PRIORITY：1</p>
<p>​    　 设置优先级：setPriority(int priority); </p>
<p>​    　 获取优先级：getPriority()；</p>
<blockquote>
<p>设置优先级以后，对高优先级，使用优先调度的抢占式策略，抢占低优先级的执行。但是并不意味着高优    先级的线程一定先于低优先级的线程执行，而是从概率上来讲，概率更大而已。</p>
</blockquote>
<p> 线程通信：wait() / notify() / notifyAll()  —-&gt;java.lang.Object类中定义的方法</p>
<h4 id="一：继承Thread的方式"><a href="#一：继承Thread的方式" class="headerlink" title="一：继承Thread的方式"></a>一：继承Thread的方式</h4><p>　　　1.提供一个继承Thread类的子类 </p>
<p>　　　2.重写Thread类run():将创建的线程要执行的操作,声明在run()中 </p>
<p>　　　3.实例化Thread子类</p>
<p>　　　4.调用子类对象的start()方法</p>
<h4 id="创建多线程的方式二"><a href="#创建多线程的方式二" class="headerlink" title="创建多线程的方式二:"></a>创建多线程的方式二:</h4><p>　　　1.创建一个实现Runnable接口的类</p>
<p>　　　2.实现Runnable的run()</p>
<p>　　　3.创建当前实现类的对象</p>
<p>　　　4.将此对象作为参数传递到Thread类的构造器中,创建Thread类的对象</p>
<p>　　　5.通过Thread类的对象调用其start()</p>
<p>对比继承Thread类和实现Runnable接口的方式</p>
<p>　　　1.联系:public class Thread implements Runnable</p>
<p>　　　2.相同点:启动线程,使用的是同一个start()方法</p>
<p>　　　3.对比:实现Runnable接口要好一些. </p>
<p>　原因：①不影响类的继承,因为类是单继承的   </p>
<p>　　　　②针对于有共享数据的操作,更适合使用Runnable的方式 ,换句话说,实现Runnable接口的方式,实现了代                    码和数据的分离</p>
<p>　　　4.面试题:创建多线程有几种方法?     继承Thread类,实现Runnable接口,实现Callable接口,使用线程池</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张。—–使用实现的方式</p>
<p>　　1.问题：出现了重票和错票</p>
<p>　　2.问题出现的原因：一个窗口在没有售完票的情况下，其他的窗口参与进来，操作ticket，导致ticket输出的错            误。</p>
<p>　　3.解决的方案：当某一个窗口完全操作完ticket以后，其他窗口应该才被允许进来，继续操作ticket。</p>
<p>　　4.java如何实现的？同步机制：①同步代码块    ②同步方法 </p>
<p>　　　4.1 同步代码块：</p>
<p>​                 synchronized(同步监视器){</p>
<p>​                       //需要被同步的代码</p>
<p>​               }</p>
<p>　　　说明：需要被同步的代码：即为操作共享数据的代码</p>
<p>　　　　　　共享数据：多个线程共同操作的数据。比如：ticket</p>
<p>　　　　　　同步监视器：俗称：锁。 可以由任何一个类的对象充当。 要求：保证多个线程共用同一把锁！</p>
<p>　　　4.2 同步方法：将操作共享数据的方法，声明为同步的。此方法即为同步方法。</p>
<p>　　　　　使用同步方法解决实现方式的线程安全问题。</p>
<p>　　　　　1.默认的同步方法（非静态的）的锁是：当前对象，也就是this.</p>
<p>　　　　　2.默认的同步方法（静态的）的锁是：当前类本身.</p>
<p>　　　　　　使用同步方法解决继承方式的线程安全问题：</p>
<p>　　　　　注意：继承的方式中，要慎用同步方法。</p>
<p>​        5.好处：线程的同步机制，解决了线程的安全问题。</p>
<p>​        6.劣势：在操作共享数据过程中，是单线程的。</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张     —–使用实现的方式</p>
<p>　　解决线程安全问题的方式三：ReentrantLock</p>
<p>　　存在线程的安全问题，使用Lock的方式解决线程安全问题。</p>
<p>面试题：同步的方式和Lock的方式，解决线程安全方面的异同？</p>
<p>　　同：解决了线程安全问题</p>
<p>　　异：同步的方式：同步监视器在线程执行完操作共享数据的代码以后，自动释放</p>
<blockquote>
<p> Lock的方式：需要显式的调用unlock()方法之后，才能保证其他线程操作共享数据。 </p>
</blockquote>
<p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，是我们开发中需要规避的！</p>
<p>线程的通信：</p>
<ul>
<li><p>wait():一个线程在执行过程中，一旦调用此方法，则此线程进入阻塞状态，等待其他线程来唤醒自己。    </p>
</li>
<li><p>notify():一个线程在执行过程中，一旦调用此方法，则会唤醒被wait()的一个线程。高优先级的要优先被唤醒。</p>
</li>
<li><p>notifyAll():一个线程在执行过程中，一旦调用此方法，则会唤醒所有被wait()的线程。</p>
</li>
</ul>
<p>　　　例题：使用两个线程打印 1-100. 线程1, 线程2 交替打印</p>
<p>注意点：1.此三个方法必须使用在同步中。</p>
<p>　　　　2.此三个方法的调用者是同步监视器！否则，如果三个方法的调用者不是同步监视器，报异常。</p>
<p>　　　　3.此三个方法定义在Object类</p>
<p>面试题：sleep() 和  wait() 的异同？</p>
<p>　　1.方法声明在哪？ Thread:sleep()   Object:wait()</p>
<p>　　2.共同点：使得当前线程进入阻塞状态</p>
<p>　　3.使用的范围要求：sleep()使用没有情境的要求；wait()必须使用在同步代码块或同步方法中</p>
<p>　　4.都使用在同步当中的话：wait()需要唤醒：notify()/notifyAll();  sleep():不会释放锁；wait()会释放锁 </p>
<p> String:字符串</p>
<p>　　　1.字符串声明的数据，会存储在字符串常量池中。第一次声明时，需要创建相应的字符串。之后，如果声明的变量，其值与之前存在的字符串内容相同，则直接引用现成的字符串。</p>
<p>　　　2.面试题：String s3 = new String(“javaEE”);创建的对象，在内存中生成了几个对象？</p>
<p><strong>String:代表着不可变的字符序列。</strong></p>
<p>　　　1.String类的声明public final class String implements java.io.Serializable, Comparable<String>, 　　　　CharSequence</String></p>
<p>　　　　　①String声明为final，不可被继承。</p>
<p>　　　　　②实现Serializable：表明String可序列化。浏览器/客户端&lt;—&gt;服务器端     进程1&lt;—-&gt;进程2    　　　　　　“{name=Tom,age=12}”    JSON:本质就是String</p>
<p>　　　　　③String重写了hashCode()/equals():常常将Map的key声明为String型。</p>
<p>　　　　　④实现Comparable接口：String可以比较大小。</p>
<p>　　　　　⑤实现CharSequence接口：String的底层声明了char[] value数组。</p>
<p>　　　2.如何理解String的不可变性：</p>
<p>　　　　　①向现有的字符串后添加新的字符串，必须声明新的字符串空间</p>
<p>　　　　　②将现有的字符串替换为新的字符串，必须声明新的字符串空</p>
<p>　　　　　③只替换现有字符串中的指定某个字符，也必须声明新的字符串空间</p>
<p>String类与其它结构的转换：</p>
<p>　　　1.String 与包装类、基本数据类型变量间的转换    </p>
<p>　　　　String–&gt;包装类、基本数据类型:调用包装类Xxx的parseXxx(String s)方法</p>
<p>　　　　包装类、基本数据类型 –&gt;String:调用String的valueOf(xxx xxx); </p>
<p>　　　2.String 与 字节数组间的转换   </p>
<p>　　　　String –&gt; 字节数组:调用String类的getBytes()</p>
<p>　　　　字节数组–&gt;String:new String(byte[] buffer,startIndex,length)</p>
<p>　　　3.String 与 字符数组间的转换</p>
<p>　　　　String –&gt; 字符数组：调用String类的toCharArray()</p>
<p>　　　　字符数组 –&gt;String:new String(char[] cbuf,startIndex,length)    </p>
<p>​         </p>
<ul>
<li><p>public String substring(int startpoint):返回当前字符串中从startPoint位置开始，到末尾的子字符串。  </p>
</li>
<li><p>public String substring(int start,int end):返回当前字符串中从startPoint位置开始，到end结束的左闭右开区间的子字符串。</p>
</li>
<li><p>pubic String replace(char oldChar,char newChar):将字符串中指定的所有oldChar替换为newChar.</p>
</li>
<li><p>public String replaceAll(String old,String new):将字符串中指定的所有old替换为new.</p>
</li>
<li><p>public String trim():去除字符串首尾的空格</p>
</li>
<li><p>public String concat(String str):连接两个字符串</p>
</li>
<li><p>public boolean contains(CharSequence s)：判断当前字符串中是否包含s.</p>
</li>
<li><p>public String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。</p>
</li>
</ul>
<ul>
<li><p>public int length():返回当前字符串的长度</p>
</li>
<li><p>public char charAt(int index)：获取指定索引位置的字符</p>
</li>
<li><p>public boolean equals(Object anObject)：比较两个字符串内容是否相等。</p>
</li>
<li><p>public int compareTo(String anotherString):比较两个字符串的大小</p>
</li>
<li><p>public int indexOf(String s):返回s在当前字符串中首次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int indexOf(String s ,int startpoint):</p>
</li>
<li><p>public int lastIndexOf(String s):返回s在当前字符串中末次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int lastIndexOf(String s ,int startpoint):</p>
</li>
<li><p>public boolean startsWith(String prefix)：判断当前的字符串是否以指定的prefix字符串开始的</p>
</li>
<li><p>public boolean endsWith(String suffix)：判断当前的字符串是否以指定的suffix字符串结束的</p>
</li>
<li><p>public boolean regionMatches(int firstStart,String other,int otherStart ,int length)   ？</p>
</li>
</ul>
<p>面试题：</p>
<p>　　String:不可变的字符序列；底层使用char[]存储</p>
<p>　　StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储  </p>
<p>　　StringBuilder:可变的字符序列；线程不安全的，效率高，(jdk 5.0新增)；底层使用char[]存储</p>
<p>类比：String —&gt;数组； StringBuffer —&gt;Vector   StringBuilder —&gt;ArrayList</p>
<p>　　　ArrayList list = new ArrayList();</p>
<p>　　　list.add(123);//new Object[10];</p>
<p>　　　….</p>
<p>　　　扩容:1.5倍的方式扩容。</p>
<p>　　　这里：</p>
<p>　　　　String str = new String();//new char[0];</p>
<p>　　　　str.length();</p>
<p>　　　　String str1 = new String(“abc”);//new char[]{‘a’,’b’,’c’};</p>
<p>　　　对比：</p>
<p>　　　　StringBuffer s1 = new StringBuffer();//char[] value = new char[16]</p>
<p>　　　　StringBuffer s2 = new StringBuffer(10);//char[] value = new char[10]</p>
<p>　　　　s1.append(“abc”);//value[0] = ‘a’,value[1] = ‘b’,value[2] = ‘c’;</p>
<p>　　　　　… </p>
<p>　　　　　　  每次添加时，都需要判断底层的char[]是否能够盛装下新要添加的字符串。</p>
<p>　　　　　　 如果不能盛装下，需要扩容。默认扩容为原来的2倍 + 2.   </p>
<p>　　　 启示：StringBuffer s1 = new StringBuffer(int capacity);开发中建议使用此构造器。</p>
<p>StringBuffer中的方法：</p>
<ul>
<li><p>StringBuffer append(String s),</p>
</li>
<li><p>StringBuffer append(int n) ,</p>
</li>
<li><p>StringBuffer append(Object o) ,</p>
</li>
<li><p>StringBuffer append(char n)，</p>
</li>
<li><p>StringBuffer append(long n),</p>
</li>
<li><p>StringBuffer append(boolean n),</p>
</li>
<li><p>StringBuffer insert(int index, String str)</p>
</li>
<li><p>public StringBuffer reverse()</p>
</li>
<li><p>StringBuffer delete(int startIndex, int endIndex):删除当前可变字符串中从startIndex到endIndex结束的左闭右开区间的数据。</p>
</li>
<li><p>public char charAt(int n )</p>
</li>
<li><p>public void setCharAt(int n ,char ch)</p>
</li>
<li><p>StringBuffer replace( int startIndex ,int endIndex, String str)</p>
</li>
<li><p>public int indexOf(String str)</p>
</li>
<li><p>public String substring(int start,int end)</p>
</li>
<li><p>public int length()</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　增：append(Xxx xxx)</p>
<p>　　删：delete(int startIndex, int endIndex</p>
<p>　　改：setCharAt(int n ,char ch) / replace( int startIndex ,int endIndex, String str)</p>
<p>　　查：charAt(int n)</p>
<p>　　插：insert(int index, String str)</p>
<p>　　长度：length()</p>
<p>　　遍历：使用for + charAt()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="顾思君"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">顾思君</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gusijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gusijun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/nightmare_dimple" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;nightmare_dimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">古俊</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">76k</span>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
