<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"b2t":true,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="思君の博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="思君の博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="顾思君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>思君の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="思君の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思君の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">38</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day11/" class="post-title-link" itemprop="url">day11</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:35:39" itemprop="dateModified" datetime="2020-02-12T14:35:39+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面向对象的特性之二: 继承性 what ?  why ? how ? </p>
<p>　　1.继承性的好处:</p>
<p>　　　①减少了代码的冗余，提高了代码的复用性  </p>
<p>　　　②更好的扩展性   </p>
<p>　　　③为多态的使用提供了前提 </p>
<p>　　2.格式:class A extends B  extends:继承,(延展,扩展)      子类(SubClass):A      父类(SuperClass,超类,基类):B  </p>
<p>　　3.说明:子类A继承父类B以后,就获取了父类中声明的结构:属性，方法 </p>
<p>　　　　3.1 不管父类中的属性或方法或权限如何，子类都可以获取到  </p>
<p>　　　　3.2 但是由于封装性的影响,可能在子类中不能直接调用父类中的权限较小的属性或方法</p>
<p>　　4.子类可以可以在继承父类的基础之上,提供自己特有的属性和方法    </p>
<p>　　　区别于:集合与子集   </p>
<p>　　5.子类和父类是相对的概念      </p>
<p>　　　子类通过继承，可以获取直接父类以及所有的间接父类中声明的所有属性或方法    </p>
<p>　　　一个父类可以被多个子类所继承 </p>
<p>　　　子类只能声明一个父类—-&gt;java类的单继承类</p>
<p>　　6.</p>
<p>　　　6.1 如果一个类没显示的继承一个类的话，则其父类为：java.lang.Object类 </p>
<p>　　　6.2 任何一个类(java.lang.Object 类)都能直接或者间接的继承于java.lang.Object类 </p>
<p>　　　6.3 任何一个类在继承java.lang.Object 之后，就获取了Object类中声明的属性和方法</p>
<p>　方法的重写(override / overwrite)   </p>
<p>　　　1.定义:子类在继承了父类以后，可以对父类中的同名同参数的方法进行“覆盖”或“覆写”</p>
<p>　　　2.重写以后，如果我们创建子类的对象，通过子类的对象调用子父类中同名的方法，执行的的是子类重写</p>
<p>　　　　类的方法  </p>
<p>　　　3.子类重写的方法，父类被重写的方法      </p>
<p>　　　　方法的声明:权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ } </p>
<p>　　　　子类重写的方法与父类被重写方法的方法名和形参列表相同  </p>
<p>　　　　​子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符     </p>
<p>　　　　特别的，子类不能重写父类中声明private的方法(因为子类中看不到)       </p>
<p>　　　　子类重写方法的返回值类型 不大于父类被重写方法的返回值类型 </p>
<p>　　举例: 1.父类方法的返回值类型是void，子类想重写，一定也是void  </p>
<p>　　　　2.父类方法的返回值类型是A，子类重写父类方法，返回值是类型A或类型A的子类，不能是类型A的父类       </p>
<p>　　　　　子类重写的方法抛出的异常类型不大于 父类被或重写方法抛出的异常类型  </p>
<hr>
<p>​         规则: 子类与父类中同名同参数的方法，必须同时声明为static(不是重写)或非static（即为重写）</p>
<p>super 关键字的使用:   </p>
<p>　　1.super 理解为:父类的    </p>
<p>　　2.super 可以用来调用属性,方法,构造器    </p>
<p>　　3.super属性,方法</p>
<p>　　　3.1 有了继承以后我们可以在子类的方法或者构造器中，可以通过“super.属性”或者“super.方法”的方法,显示的调用父类中声明的属性或者方法。但是很多情况下，我们都可以省略“super.” </p>
<p>　　　3.2 如果子类和父类中出现了同名的属性，那抹我们在子类中调用父类同名的属性的的话，必须使用“super.”的方法 </p>
<p>　　　说明:子类的属性不会覆盖父类中同名的属性。在堆空间中，两个属性都会存在  </p>
<p>　　　3.3 如果子类重写了父类的方法，那抹我们在子类中调用父类被重写的方法，必须用“super.”的方法</p>
<p>　　4.super 调用构造器: super(形参列表)  </p>
<p>　　　4.1 在子类的构造器的首行，显示的使用“super(形参列表)”的方式,调用父类指定的构造器  </p>
<p>　　　4.2 针对于子类的某一个构造器而言，最多只能声明一个“super(形参列表)”  </p>
<p>　　　4.3 在子类的构造器的首行，要抹使用“this(形参列表)”,要抹使用“super(形参列表)”,不能同时出现    </p>
<p>　　　4.4 在子类构造器的首行，既没有显示的使用”this(形参列表)”，也没有显示的使用“super(形参列表)”，那抹默认提供的是：“super()”       </p>
<p>　　　4.5 在子类的多个构造器中，至少有一个构造器的首行使用了“super(形参列表)”</p>
<p>子类对象实例化的全过程： </p>
<p>　　1.结果上:(继承性)      子类在继承父类以后，就获取了所有的父类中声明的属性和方法  </p>
<p>　　2.过程上:  我们在实力化子类对象的过程中，一定会直接或间接调用父类的构造器，以及父类的父类的构造 器….      直到调用到java.lang.Object的空参构造器，正因为加载了这些父类的结构，所以,在子类对象的内存中才有所有父类中声明的属性或方法  </p>
<p>说明:在子类对象整个实例化过程中，只创建了唯一的一个对象，即为当前的子类对象</p>
<p>​    </p>
<p>面向对象的特征三:多态性的使用 </p>
<ul>
<li><p>多态性:可以理解为一个事物的多种形态   </p>
</li>
<li><p>广义上多态性的体现:  </p>
<p>①方法的重写和重载      ②子类对象的多态性   </p>
</li>
<li><p>狭义上多态性的体现: 子类对象的多态性  </p>
</li>
<li><p>子类对象的多态性:父类的引用指向子类的对象(子类的对象赋给父类的引用)   </p>
</li>
<li><p>多态的应用场景      </p>
<p>　虚拟方法调用:编译时,认为调用的方法是父类的,但是当运行时，实际上执行的是子类重写父类的方法   </p>
<p>　总结:多态中方法的调用:编译看左边，运行看右边。</p>
</li>
<li><p>多态性,只适用于方法 !</p>
</li>
<li><p>多态性使用的前提:①类的继承关系 ②要有方法的重写</p>
</li>
</ul>
<p>​     </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day16/" class="post-title-link" itemprop="url">day16</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:57:16" itemprop="dateModified" datetime="2020-02-12T13:57:16+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.java中的容器–在内存层面,对数据进行统一的存储和管理:数组 ；java集合</p>
<p>​    扩展:数据的持久化:文件(.jpg;mp3); xml ; 数据库</p>
<p>2.数组在内存存储方面的特点:</p>
<p>　　①数组初始化以后,长度就确定了                </p>
<p>　　②数组类型声明后，就决定了进行元素初始化的类型   </p>
<p>弊端:数组初始化以后,长度就不可变了</p>
<p>　　数组中提供的属性和方法很少,不便于进行添加,删除,插入等操作            </p>
<p>　　数组存储的数据是有序的,可以重复的—–&gt;存储数据的特点单一    </p>
<p>　　String[] arr = new String[10]      </p>
<p>　　Object[]  </p>
<p>3.集合框架     </p>
<p>　java.util.Collection:单列数据</p>
<p>　|——-List子接口:存储有序的,可重复的数据—-&gt;“动态”数组</p>
<p>　　　|—–ArrayList:作为List的主要实现类,线程不安全的,效率高；底层使用数组</p>
<p>　　　|—–LinkedList:对于频繁的插入,删除操作，我们建议使用此类,效率高；底层使用双向链表实现       </p>
<p>　　　|—–Vector:List的古老实现类,线程安全的,效率低；底层使用数组实现</p>
<p>​     [面试题] ArrayList,LinkList,Vector区别?</p>
<p>　　　　共同点:ArrayList,LinkList,Vector都是List接口的实现类,存储的数据都是有序的,可重复的</p>
<p>　　　　　　　区别:如上</p>
<p>　　　　　　　List list = new ArrayList();</p>
<p>　　　　　　　list.add(..);</p>
<p>　　　　　　　…</p>
<p>　　　　　　　一旦添加元素超出底层数组的长度,就需要扩容,默认扩容需要为原来的1.5倍，同时              </p>
<p>　　　　　　　需要将原有数组中的元素复制到新的数组中。</p>
<p>实际情况:需要存储80个数据到ArrayList中,建议:List list = new ArrayList(85);            </p>
<p>　　　|——-Set子接口:存储无序的,不可重复的数据—-&gt;高中讲的“集合”</p>
<p>　　　　　　|—- HashSet 主要实现类,底层实现:HashSet底层使用了HashMap</p>
<p>　　　　　　|—- LinkedHashSet 是HashSet的子类,可以按照添加的顺序实现遍历     </p>
<p>　　　　　　　　(原因:在HashSet底层存储上的基础上,额外使用了一对指针,能够记录此Node元素的</p>
<p>　　　　　　　　 上一个元素和下一个元素) —&gt; 对于频繁的遍历，效率高</p>
<p>　　　　　　|—- TreeSet : 可以按照添加元素的指定属性的大小实现遍历。底层实现：红黑树</p>
<p>　　　　　　 TreeSet的使用</p>
<p>　　　　　　　　　1.向TreeSet中添加的元素必须是同一个类创建的对象</p>
<p>　　　　　　　　　2.TreeSet排序的方式:①自然排序 ②定制排序</p>
<p>　　　　　　　　　3.自然排序: </p>
<p>　　　　　　　　　　　①要求添加的元素所在的类实现Compare接口 </p>
<p>　　　　　　　　　　　②重写接口中的CompareTo(Object obj)—&gt;指明排序的规则</p>
<p>　　　　　　　　　　　　如果此方法返回值0，则要新添加的元素添加不成功</p>
<p>　　　　　　　　　　　③向TreeSet添加此实现类的对象即可</p>
<p>　　　　　　　　　定制排序：</p>
<p>　　　　　　　　　　　TreeSet的定制排序:     </p>
<p>　　　　　　　　　　　　1.提供Comparator接口匿名实现类的对象 </p>
<p>　　　　　　　　　　　　2.重写其中的compare(Object o1,Object o2),指明排序的规则 </p>
<p>　　　　　　　　　　　　3.将此实现类的对象作为参数传递到TreeSet的构造器中   </p>
<p>　　　　　　　　　　　　4.向TreeSet的对象中添加compare()方法中判断类的对象</p>
<blockquote>
<p>　总结:   元素是否能add成功,是否能remove,是否contains…..</p>
<p>　　　　都依赖于compareTo或者compare方法   与元素所在类的hasCode/equals无关</p>
</blockquote>
<p>set作为Collection的子接口,没有定义额外的方法set:存储无序的,不可重复的元素  </p>
<ol>
<li><p>无序性！= 随机性.添加的元素,需要计算哈希值,此哈希值决定了在底层储存的位置,从存储位置上看,  是无序的</p>
</li>
<li><p>不可重复性:保证set集合中不同对象使用对象所属类的equals()方法判断的话,一定返回false。</p>
</li>
<li><p>如何向Set中添加一个元素?哈希算法   </p>
</li>
</ol>
<p>　　　向Set中添加元素a,首先通过hasCode()，计算元素的哈希值,此哈希值就决定了此元素在Set底层</p>
<p>　　　存储的位置，如果此存储位置上没有元素,则此元素a添加成功 ，如果此存储的位置上有元素b,则</p>
<p>　　　调用元素a所在类的equals（）方法.将元素b作为参数传递过去,如果返回值为true，则表示元素</p>
<p>　　　a和元素b相同，添加不成功，如果返回值为false,则认为元素a和元素b不相同,此时元素b可以添</p>
<p>　　　加成功的.元素a和元素b使用链表存储（jdk7.0:a指向b；JDK8.0:b指向a）  </p>
<p>　4.向Set中添加的元素,要求其所在的类要重写两个方法:  equals() 和 hashCode() </p>
<p>　5.必须要求添加的元素所在的类中重写equals() 和 hashCode（）保持一致</p>
<p>Map:存储的是双列数据：key-value </p>
<p>　1.所有的key构成的是集合是set:无序的,不可重复的 </p>
<p>　2.所有value构成的是集合Collection:无序的,可以重复的 </p>
<p>　3.一个key-value构成一个Entry</p>
<p>　4.所有的Entry构成的集合是Set:无序的,不可重复的</p>
<p>　HashSet的底层使用HashMap存储的</p>
<p>　HashMap的所有key构成的集合是HashSet</p>
<p>|—-HashMap:Map的主要实现类,线程不安全,效率高；可以存储null的key和value</p>
<p>　　 (存储结构：Jdk7.0数组+链表,Jdk8.0数组+红黑树) </p>
<p>　　|—-LinkedHashMap:HashMap的子类,可以按照添加的顺序遍历,对于频繁的遍历效率</p>
<p>　　(在HashMap存储的基础上,使用了一对指针,来记录添加元素的顺序)</p>
<p>|—-TreeMap：可以按照key的指定的属性进行排序,遍历,底层实现:红黑树</p>
<p>|—-Hashtable：Map的古老实现类:线程安全,效率低;不可以存储null的key和value </p>
<p>　　　|—-Properties:Hashtable的子类，常常用来处理属性文件，其key和value都是String类型的</p>
<p>Map常用方法：</p>
<p>　添加:put(Object key,Object value)</p>
<p>　修改:put(Object key,Object value)</p>
<p>　删除:Object remove(Object obj)</p>
<p>　长度:size()</p>
<p>　清空数据:clear()</p>
<p>　是否为空isEmpty()</p>
<p>1.遍历所有的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Set keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">  Iterator iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123; </span><br><span class="line"></span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​     2.遍历所有的value</p>
<p>​       </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = map.values();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(Object obj:coll)&#123;  </span><br><span class="line"></span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>​    3.遍历所有的key-value</p>
<p>​          1.方式一：</p>
<p>​         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set keySet1 = map.keySet();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(Object key:keySet1)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(key+<span class="string">"----&gt;"</span>+map.get(key));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>​         2.方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object o:entrySet)&#123; </span><br><span class="line"></span><br><span class="line">              Map.Entry entry = (Map.Entry)o;</span><br><span class="line"></span><br><span class="line">              System.out.println(entry.getKey()+<span class="string">"********"</span>+entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>Map常用方法：</p>
<ul>
<li>添加:put(Object key,Object value)</li>
<li>修改:put(Object key,Object value)</li>
<li>删除:Object remove(Object obj)</li>
<li>长度:size()</li>
<li>清空数据:clear()</li>
<li>是否为空isEmpty()</li>
</ul>
<p> 总结:</p>
<p>　　增：put(Object key,Object value)</p>
<p>　　删：Object remove(Object obj)</p>
<p>　　改：put(Object key,Object value)</p>
<p>　　查：get(Object key)</p>
<p>　　长度:size()</p>
<p>　　遍历:keySet() / values() / entrySet()List (index—&gt;数据)/ Set（很少用）/ Map（key –&gt; 数据）</p>
<p>   说明：1.向List中添加自定义类的对象的话,要求此定义类要重写equals()方法</p>
<p>　　　　2.补充:数据结构解决两个问题:</p>
<p>　　　　　　　1.数据之间逻辑关系：一对一，一对多，多对多…</p>
<p>　　　　　　　2.数据的存储结构:①顺序存储:一维数组 ②链式存储</p>
<p> 4.测试Collection中的常用方法</p>
<p>​       ①size（）返回集合中存储的元素的个数</p>
<p>​       ②add(Object obj) 将obj添加到当前的集合中</p>
<p>​       ③addAll(Collection coll) 将coll1集合中的所有元素添加到当前集合中</p>
<p>​       ④isEmpty() 判断当前集合是否为空</p>
<p>​       ⑤clear 清除当前集合</p>
<p>​       ⑥contains(Object obj) 判断当前集合中是否包含obj：调用了obj所在类的equals（）方法</p>
<p>​       ⑦containsAll(collection coll)    当前集合是否包含coll中的所有元素</p>
<p>​       ⑧remove(Object obj):从当前集合中移除obj元素.仍然需要obj所在类的equals的方法</p>
<p>​       ⑨removeAll(Collection coll):差集:从当前集合中移除coll集合中的元素</p>
<p>​       ⑩retainAll(Collection coll)：交集：获取当前集合和coll共有的元素</p>
<p>​       ⑪equals(Object obj):比较当前对象和obj是否相等。</p>
<p>​       ⑫hashCode():获取当前对象的哈希值</p>
<p>​       ⑬toArray()：将集合转换成数组:Object[]</p>
<p>​       ⑭toArrays(T[] arr):略</p>
<p>​       ⑮Iterator():集合元素的遍历。迭代器</p>
<p>​          hasNext():判断是否还有下一个元素</p>
<p>​          next():①指针下移 ②将指针下移以后集合位置上的元素返回</p>
<p>5.规定：如果集合中存储自定义类的对象，要求自定义重写equals方法</p>
<p>6.集合：很常用。</p>
<p>　　掌握点：层次一：选择合适的集合类实现数据的保存,调用其内部的相关方法</p>
<p>　　　　　　层次二:不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</p>
<p> 集合的遍历:</p>
<p>　方式一：使用Iterator实现</p>
<p>　方式二：增强for循环(foreach循环)</p>
<p>　　　　　for(集合元素的类型 局部变量 : 集合引用)</p>
<p>List:</p>
<p>在Collection的基础上，新增的方法：</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 </li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置.如果不存在，返回-1.</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置.如果不存在，返回-1.</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为eleList</li>
<li>subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合    </li>
<li>substring(int from ,int to) /  read(int from,int length)  </li>
</ul>
<p>​      总结：List中的常用方法：</p>
<p>　　　增：add(Object obj)</p>
<p>　　　删：remove(Object obj) / remove(int index)  </p>
<p>　　　改：set(int index, Object ele)</p>
<p>　　　查：get(int index)</p>
<p>　　　插：add(int index, Object ele)</p>
<p>　　　遍历：iterator();增强for;for   </p>
<p>　　　长度：size()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day18/" class="post-title-link" itemprop="url">day18</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:33:44" itemprop="dateModified" datetime="2020-02-12T13:33:44+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>泛型的应用:</p>
<p>　1.JDK 5.0 新增的特性</p>
<p>　2.主要内容：</p>
<p>　　2.1 在集合中使用泛型</p>
<p>　　2.2 如何自定义泛型类,泛型接口,泛型方法(理解)</p>
<p>　　2.3 泛型在继承上的体现(掌握)</p>
<p>　　2.4 通配符的使用（掌握）</p>
<p>在集合中使用泛型的情况</p>
<p>在集合中使用泛型</p>
<p>　1.在Java的集合中,声明的接口或者类已经声明泛型</p>
<p>　2.我们在实例化接口时,可以指明泛型的类型</p>
<p>　3.不能使用基本数据类型,需要使用对应的包装类替换</p>
<p>　4.一旦创建对象时,使用了泛型,则通过对象调用方法,属性时,如果方法或属性使用了类的泛型,   则此时泛型类型就是对象实例化时候的类型</p>
<p>　5.如果实例化时候,不指明泛型参数,则默认是Object类型</p>
<p>自定义泛型类:</p>
<p>　仿照List去创建</p>
<p>　1.在类的声明后面,指明泛型参数,参数通常使用:T E K V</p>
<p>　2.在类的属性,方法,构造器中,可以使用类的泛型参数</p>
<ul>
<li>使用了类的泛型参数的方法,不能声明为static的</li>
<li>不能在try-catch中使用泛型参数表示异常类型</li>
</ul>
<p>关于自定义泛型类,泛型接口,泛型方法的使用</p>
<p>　自定义泛型类的使用:</p>
<p>　　1.在实例化泛型类时,可以指明泛型的参数类型</p>
<p>　　2.提供泛型类的子类时,可以指明泛型的参数类型.比如:SubOrder1类</p>
<p>泛型在继承上的体现</p>
<p>　　1.如果A类是B类的父类,则List<A>与List<B>是没有子父类的关系的  </B></A></p>
<p>　　　扩展：则G<A> 和 G<B>没有子父类关系！</B></A></p>
<p>　　2.如果A类是B类的父类,则A<G> 是 B<G>的父类</G></G></p>
<p>通配符: ? 的使用：</p>
<p>　　A类是B的父类,则G<A> 和 G<B> 的公共父类为G&lt;?&gt;</B></A></p>
<p>　关于数据的读写问题</p>
<p>　写入数据:不允许向使用通匹配符的集合中写入数据，除非可以写入null</p>
<p>　读取数据：可以从使用了通配符的集合中读取数据。读取的数据的类型默认是Object</p>
<p>有限制条件的通配符的使用? </p>
<p>？  extends A:举例:List&lt;? extends A&gt; 可以作为List<B>或者List<A>的父类,其中B类是A类的子类?</A></B></p>
<p>？   super A: 举例:List&lt;? super A&gt; 可以作为List<B>或List<A>的父类,其中B类是A类的父类</A></B></p>
<p>File类：</p>
<p>　 1.java.io包下定义的</p>
<p>　 2.一个File类的对象，既可以表示一个文件(.txt,.mp3,.avi,mp4,.doc)，也可以表示一个文件目录。</p>
<p>　 3.File类中只涉及到文件或文件目录的新建、删除、长度、修改时间、重命名等操作。没有涉及到对文件内容的修改。如果需要对文件内容进行修改的话，需要使用流。</p>
<p>　 4.File类的对象常常作为流的构造器的参数出现。</p>
<p>　 5.File类的对象代表着流资源读取或写入到的文件。</p>
<p>  File类的实例化 </p>
<p>  　 绝对路径：包含盘符在内的文件或文件目录的完整路径 </p>
<p>  　 相对路径：相较于某一层文件路径来讲。比如：在Eclipse中的相对路径是相较于当前工程的。 </p>
<p>   两个构造器： </p>
<p>　　File(String pathname) </p>
<p>　　File(String parent,String pathname)</p>
<p>获取文件名:</p>
<p>getName()</p>
<p>getPath()</p>
<p>getAbsoluteFile()</p>
<p>getAbsolutePath()</p>
<p>getParent()</p>
<p>toPath()</p>
<p>renameTo(File newName)</p>
<p>   file1.renameTo(File file2):file1重命名为file2是否成功</p>
<p>   如果希望返回值为true.则必须：file1对应的物理磁盘上的文件需要存在，且file2对应的物理磁盘上的文件不存在。</p>
<p>文件检测:</p>
<p>   exists()</p>
<p>   canWrite()</p>
<p>   canRead()</p>
<p>   isFile()</p>
<p>   isDirectory()</p>
<p>获取文件常规信息:</p>
<p>   lastModified()</p>
<p>   length()</p>
<p>  操作文件相关的：</p>
<p>​    createNewFile()：在物理磁盘上创建指定路径的文件</p>
<p>​    delete():删除物理磁盘上指定路径的文件</p>
<p>  操作文件目录相关的：</p>
<p>​    mkdir()/mkdirs():如果要创建的文件目录的上层目录存在，则二者没有区别。</p>
<p>​    如果要创建的文件目录的上层目录不存在，mkdir()创建不成功，mkdirs()创建成功。</p>
<p>   delete()：删除物理磁盘上指定路径的文件目录list()listFiles()</p>
<p>list() / listFiles()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day17/" class="post-title-link" itemprop="url">day17</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:36:35" itemprop="dateModified" datetime="2020-02-12T13:36:35+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>731</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Collections:用来操作集合框架(Collection / Map)的工具类</p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object  </li>
<li>object min(Collection)</li>
<li>Object min(Collection，Comparator)</li>
<li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li>
</ul>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中</li>
</ul>
<p>　　List dest = Arrays.asList(new Object[list.size()]);</p>
<p>　　Collections.copy(dest, list);</p>
<p>　　System.out.println(dest);</p>
<ul>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li>
</ul>
<p>  list:线程不安全的。</p>
<p>  List newList = Collections.synchronizedList(list);</p>
<p>  newList:线程安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day20/" class="post-title-link" itemprop="url">day20</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:19:01" itemprop="dateModified" datetime="2020-02-12T14:19:01+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk 7.0 时，引入了 Path、Paths、Files三个类。</p>
<p>　1.此三个类声明在：java.nio.file包下。</p>
<p>　2.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关</p>
<p>　3.如何实例化Path:使用Paths. </p>
<p>　　static Path get(String first, String … more) : 用于将多个字符串串连成路径</p>
<p>　　static Path get(URI uri): 返回指定uri对应的Path路径 </p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path:"></a>Path:</h2><p>   String toString() ： 返回调用 Path 对象的字符串表示形式</p>
<p>   boolean startsWith(String path) : 判断是否以 path 路径开始</p>
<p>   boolean endsWith(String path) : 判断是否以 path 路径结束</p>
<p>   boolean isAbsolute() : 判断是否是绝对路径</p>
<p>   Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</p>
<p>   Path getRoot() ：返回调用 Path 对象的根路径</p>
<p>​       Path getFileName() : 返回与调用 Path 对象关联的文件名</p>
<p>​       int getNameCount() : 返回Path 根目录后面元素的数量(层数)</p>
<p>​       Path getName(int idx) : 返回指定索引位置 idx 的路径名称</p>
<p>​       Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</p>
<p>​       File toFile(): 将Path转化为File类的对象</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制      </p>
<p>​    &gt;要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</p>
<p>​      Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING); 当已存在时做覆盖</p>
<p>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录      </p>
<p>​      要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</p>
<p>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件      </p>
<p>​      要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</p>
<p>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</p>
<p>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</p>
<p>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置      </p>
<p>   要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</p>
<p>   Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</p>
<p>long size(Path path) : 返回 path 指定文件的大小</p>
<p>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</p>
<p>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</p>
<p>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</p>
<p>boolean isHidden(Path path) : 判断是否是隐藏文件</p>
<p>​    &gt;要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常</p>
<p>boolean isReadable(Path path) : 判断文件是否可读</p>
<p>boolean isWritable(Path path) : 判断文件是否可写</p>
<p>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</p>
<p>StandardOpenOption.READ:表示对应的Channel是可读的。 </p>
<p>StandardOpenOption.WRITE：表示对应的Channel是可写的。</p>
<p>StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略 StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常</p>
<p>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</p>
<p>DirectoryStream<Path>  newDirectoryStream(Path path) : 打开 path 指定的目录</Path></p>
<p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</p>
<p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</p>
<p>jdk 7 提供基于try-catch的自动资源管理</p>
<p>　能够实现资源的自动关闭，需要满足：</p>
<p>　　1.可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。</p>
<p>　　2.需要关闭的资源，必须实现了 AutoCloseable 接口或其子接口 Closeable目的：不需要再使用finally，显式的关闭资源了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day19/" class="post-title-link" itemprop="url">day19</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:30:28" itemprop="dateModified" datetime="2020-02-12T13:30:28+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  一、流的分类</p>
<p>　1.流的流向：输入流、输出流</p>
<p>　2.流中数据单位：字节流、字符流</p>
<p>　3.流的角色不同：节点流、处理流</p>
<p>  二、 抽象基类                          节点流(或文件流)                                       缓冲流(处理流的一种)：提高数据读写效率</p>
<p>​          InputStream                   FileInputStream(read(byte[]))                 BufferedInputStream(read(byte[])</p>
<p>​          OutputStream               FileOutputStream(write(byte[],0,len))  BufferedOutputStream(write(byte[],0,len)</p>
<p>​         Readed                            FileReader(read(char[]))                          BufferedReader(read(char[]) / readLine())</p>
<p>​         Writer                              FileWriter(write(char[],0,len))                  BufferedWriter(write(char[],0,len)</p>
<p>从指定文件中读取数据到控制台上</p>
<p>　1.要去读的文件一定要存在的,否则报FileNotFoundException</p>
<p>　2.因为需要保证流的资源关闭,所以异常的处理需要使用try-catch-finally</p>
<p>字节流：</p>
<p>　输入流:FileInputStream</p>
<p>　1.创建一个文件,指明读取数据的来源</p>
<p>　2.将file对象作为参数传递到流的构造器中,创建一个字节的输入流:FileInputStream</p>
<p>　3.read():读取文件中的下一个字节。如果到达文件末尾的话,返回-1</p>
<p>　4.关闭资源</p>
<p> 输出流:FileOutputStream</p>
<p>　1.造文件</p>
<p>　2.造流:输出流</p>
<p>　3.写出数据  getBytes()  字符串—&gt;字节数组</p>
<p>　4.关闭资源</p>
<p>　　* 如果输出的文件不存在,则在输出执行的过程中,自动创建此文件<br>　　* 如果输出的文件存在：如果使用构造器：FileOutputStream(file)是对已存在的文件的覆盖, </p>
<p>​                                              如果使用构造器:FileOutputStream(file,true)是在已有文件内容的基础上,继续写入内容</p>
<p>字符流</p>
<p>　 FileReader 和 FileWriter的使用：只能用来处理文本文件的。</p>
<p>　FileInputStream 和  FileOutputStream:适合用来处理非文本文件：.avi , .mp3, .jpg, .doc</p>
<p>   1.造文件</p>
<p>   2.造流：字符的输入流、字符的输出流</p>
<p>   3.读取数据并写出</p>
<p>   4.关闭资源</p>
<p>缓冲流的使用。</p>
<p>　1.缓冲流是处理流的一种</p>
<p>　2.作用：提高数据的读写效率</p>
<p>　3.类： 处理非文本文件：</p>
<p>　　　BufferedInputStream</p>
<p>　　　BufferedOutputStream</p>
<p>　　　　处理文本文件：</p>
<p>　　　BufferedReader</p>
<p>　　　BufferedWriter  —&gt;readLine 读取一行</p>
<p>　　　　　　　　　　　—&gt;newLine 开始新的一行</p>
<p>理流之二：转换流</p>
<p>　1.转化流的作用：能够实现字节流与字符流之间的转换</p>
<p>　2.涉及到的流：</p>
<p>　　　InputStreamReader:实现字节的输入流转换为字符的输入流</p>
<p>　　　OutputStreamWriter:实现字符的输出流转换为字节的输出流</p>
<p>　　编码的过程：字符串、字符数组—&gt;字节数组</p>
<p>　　解码的过程：字节数组—-&gt;字符串、字符数组</p>
<p> 3.常见的编码集：</p>
<p>　ASCII：美国标准信息交换码，用一个字节的7位可以表示。</p>
<p>　ISO8859-1：拉丁码表。欧洲码表.  用一个字节的8位表示。</p>
<p>　GB2312：中国的中文编码表。</p>
<p>　GBK：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p>　Unicode：国际标准码，融合了多种文字。 所有文字都用两个字节来表示,Java语言使用的就是unicode</p>
<p>　UTF-8：最多用三个字节来表示一个字符</p>
<p>处理流之三：标准的输入、输出流 </p>
<p>　System.in:标准的输入流，默认从键盘输入 </p>
<p>　<em>System.out:标准的输出流，默认从显示屏输出</em> </p>
<p>　 System.setIn():重新指定输入的位置 </p>
<p>　System.setOut():重新指定输出的位置</p>
<p>处理流之四：打印流 PrintStream 和 PrintWriter</p>
<p>处理流之五：数据流 DataInputStream 和 DataOutpuStream</p>
<p>处理流之六：对象流</p>
<p>　1.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中， 也能把对象从数据源中还原回来。</p>
<p>　2.涉及到的流：ObjectInputStream 和 ObjectOutputStream</p>
<p>　3.对象序列化机制：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象.</p>
<p>提供一个自定义类，实现序列化机制。</p>
<p>　要求：1.自定义类实现Serializable接口</p>
<p>　　　　2.需要给当前的类声明全局的常量：serialVersionUID</p>
<p>　　　　3.要求类的属性也是可序列化的。 (默认情况下：String、基本数据类型都是可序列化的)</p>
<p>　　　　注意：不能序列化static和transient修饰的成员变量</p>
<p>RandomAccessFile的使用：随机存取文件流</p>
<p>　1.RandomAccessFile在java.io包下声明，直接继承于Object类</p>
<p>　2.既可以作为输入流，又可以作为输出流。</p>
<p>　3.如果输出到的文件不存在，则会在输出的过程中，自动创建此文件 。 如果输出到的文件存在，</p>
<p>　　则不是对文件的覆盖，而是对文件内容的覆盖。（默认从头覆盖）</p>
<p>　4.实现数据的“插入” </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day23/" class="post-title-link" itemprop="url">day23</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:17:04" itemprop="dateModified" datetime="2020-02-12T13:17:04+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk 8 之前 日期+时间 API的使用</p>
<p>java.util.Date类</p>
<p>　　|—-java.sql.Date类</p>
<p>1.java.util.Date类：</p>
<p>　　如何实例化：两个构造器</p>
<p>　　常用方法：toString() / getTime();</p>
<p> 2.java.sql.Date类：与数据表中的Date类型的变量对应。    </p>
<p>构造器一：获取系统当前时间对应的Date对象</p>
<p>Date date = new Date();</p>
<p>getTime()：返回当前日期对应的毫秒数：当前时间与1970-1-1 00：00：00直接的毫秒数</p>
<p>构造器二：获取毫秒数所对应的Date对象</p>
<p>Date date1 = new Date(1502768492941L);</p>
<p>SQl:</p>
<p>java.sql.Date date2 = new java.sql.Date(1502768492941L);</p>
<p>SimpleDateFormat</p>
<p>使用默认构造器:SimpleDateFormat sdf = new SimpleDateFormat();</p>
<p>格式化：String format(Date date):</p>
<p>　Date date = new Date();</p>
<p>　String dateStr = sdf.format(date);</p>
<p>解析： Date parse(String dateStr)</p>
<p>　Date date1 = sdf.parse(“17-8-15 下午2:18”);</p>
<p>　System.out.println(date1);</p>
<p>java.text.SimpleDateFormat类</p>
<p>　1.SimpleDateFormat的作用：</p>
<p>　　　格式化：日期—&gt;文本</p>
<p>　　　解析：格式化的逆过程，文本 —&gt;日期</p>
<p>　2.SimpleDateFormat实例化</p>
<p>　　使用带参数的构造器</p>
<p>　　　SimpleDateFormat sdf1 = new SimpleDateFormat(“EEE, d MMM yyyy HH:mm:ss Z”); 　　　</p>
<p>　　　SimpleDateFormat sdf1 = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);</p>
<p>　　格式化：</p>
<p>　　　String dateStr1 = sdf1.format(date);</p>
<p>　　　System.out.println(dateStr1);//2017-08-15 02:24:40</p>
<p>　　解析：</p>
<p>　　　Date date2 = sdf1.parse(“2017-08-15 02:24:40”);</p>
<p>　　　System.out.println(date2);</p>
<p>java.util.Calendar(日历)类的使用</p>
<p>　　1.实例化Calendar calendar = Calendar.getInstance();</p>
<p>　　2.get()</p>
<p>​        　int day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>​        　System.out.println(day);</p>
<p>　　3.set()</p>
<p>　　　calendar.set(Calendar.DAY_OF_MONTH, 20);　</p>
<p>　　　day =   calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　　System.out.println(day);</p>
<p>　　4.add()</p>
<p>　　　calendar.add(Calendar.DAY_OF_MONTH, -2);</p>
<p>　　　day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　　System.out.println(day);</p>
<p>日历 —&gt;日期</p>
<p>　　Date date = calendar.getTime();</p>
<p>　　System.out.println(date);</p>
<p>使用指定的Date对象，来设置calendar</p>
<p>　　Date date1 = new Date();</p>
<p>　　calendar.setTime(date1);</p>
<p>　　day = calendar.get(Calendar.DAY_OF_MONTH);</p>
<p>　　System.out.println(day);</p>
<p>LocalDate / LocalTime / LocalDateTime     —–重要//理解为对Calendar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="comment">//now()</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime =   LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//of()</span></span><br><span class="line">LocalDate localDate2 = LocalDate.of(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">15</span>); </span><br><span class="line">System.out.println(localDate2);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">11</span>,<span class="number">23</span>); System.out.println(localDateTime2);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//getXxx():</span></span><br><span class="line">System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">System.out.println(localDateTime.getMonth());</span><br><span class="line">System.out.println(localDateTime.getMonthValue());</span><br><span class="line">System.out.println(localDateTime.getHour());</span><br><span class="line">System.out.println(localDateTime.getMinute());</span><br><span class="line"><span class="comment">//withXxx():体现了不可变性</span></span><br><span class="line">LocalDateTime localDateTime3=localDateTime.withDayOfMonth(<span class="number">20</span>); System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime3);</span><br><span class="line">LocalDateTime localDateTime4=localDateTime.withHour(<span class="number">12</span>); System.out.println(localDateTime4);</span><br><span class="line"><span class="comment">//plus()//minus()</span></span><br><span class="line">LocalDateTime localDateTime5 =localDateTime.plusDays(<span class="number">3</span>); System.out.println(localDateTime5);</span><br><span class="line">LocalDateTime localDateTime6 =localDateTime.minusMinutes(<span class="number">20</span>); </span><br><span class="line">System.out.println(localDateTime6);</span><br><span class="line"><span class="keyword">boolean</span> isBefore =localDateTime.isBefore(localDateTime6); </span><br><span class="line"> System.out.println(isBefore);<span class="comment">//false</span></span><br><span class="line"><span class="keyword">boolean</span> isAfter =localDateTime.isAfter(localDateTime6); System.out.println(isAfter);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//isLeapYear():</span></span><br><span class="line">System.out.println(localDate.isLeapYear());</span><br><span class="line">LocalDate localDate3 =localDate.minusYears(<span class="number">1</span>); </span><br><span class="line">System.out.println(localDate3.isLeapYear());</span><br></pre></td></tr></table></figure>





<p>Optional类使用的测试</p>
<p>　Optional:是一个封装了具体类型数据的容器。</p>
<p>　其中，具体的类型：通过Optional的泛型体现。</p>
<p>　具体类型的数据：通过Optional内部的T value体现</p>
<p>返回一个没有封装任何数据的Optional对象</p>
<p>　　Optional<Object> op = Optional.empty();０</Object></p>
<p>　　Optional<String> op1 = Optional.ofNullable(“beijing”);</String></p>
<p>isPresent():判断内部的数据是否存在</p>
<p>get():返回Optional对象内部封装的数据</p>
<p>of(T t):当t为null时，报异常。建议不用此方法</p>
<p>orElse(T t):如果调用对象包含值，返回该值，否则返回t</p>
<p>Integer类作为int的包装类，能存储的最大整型值为2^31−1， </p>
<p>BigInteger类的数值范围较Integer类、Long类的数值范围要大得多，可以支持任意精度的整数。</p>
<p>在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p>
<p>BigDecimal类支持任何精度的定点数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day3/" class="post-title-link" itemprop="url">day3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 14:58:45" itemprop="dateModified" datetime="2020-02-12T14:58:45+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>579</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>equals   判断字符串内容</p>
<p>Math.random  [0, 1)</p>
<p>想获取【a,b】的数 ( int )(Math.random()*(b-a+1)+a)</p>
<p>分支结构2：switch-case</p>
<p>switch 语句的结束标志： } ，break</p>
<p>default 可选，位置比较灵活</p>
<p>switch中的表达式所代表的数据类型6种，只能是如下byte,short,char,int,枚举，String(jdk7.0新增)</p>
<p>case 后只能是常量或者是常量表达式</p>
<p>多个case可以共用一组语句，在最后一个case上写要执行的语句就好了，这里的最后一个case并不是}附近的一个，而是你要停止的一个</p>
<p>凡是swith-case实现的结构，都可以转成if-else实现，反之不成立</p>
<p>字符串方法：</p>
<p>获取字符：charAt()</p>
<p>循环结构4要素：</p>
<p>初始化条件</p>
<p>循环条件  —&gt;布尔类型</p>
<p>循环体</p>
<p>迭代条件</p>
<p>当循环条件返回false,结束循环</p>
<p>for和while 可以相互转换</p>
<p>循环结构的结束方式：</p>
<p> 1.循环条件返回false时</p>
<p> 2.在循环体中，判断某个条件满足时，执行break (不确定循环次数时)</p>
<p>​     while(true)   / for(;;)</p>
<p>嵌套循环：</p>
<p>一个循环结构a,作为另一个循环结构b的循环体实现</p>
<p> 内层循环：循环结构a</p>
<p> 外层循环：循环结构b</p>
<p>技巧：</p>
<p>1.外层循环控制行数</p>
<p>   内层循环控制列数</p>
<p>2.</p>
<p>内层循环循环次数为m次，外层循环循环次数为n次，则一共循环m*n次</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day22/" class="post-title-link" itemprop="url">day22</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:16:00" itemprop="dateModified" datetime="2020-02-12T13:16:00+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、继承Thread的方式</p>
<p>　　1.提供一个继承于Thread类的子类</p>
<p>　　2.重写Thread类的run():将创建的线程要执行的操作，声明在run()中。</p>
<p>　　3.实例化Thread子类</p>
<p>　　4.调用子类对象的start() </p>
<p>Thread类的常用方法的测试</p>
<p> 　　1.run():Thread的子类一定要重写的方法。将此分线程要执行的操作，声明在run()中</p>
<p>　 　2.start():要想启动一个分线程，就需要调用start():①启动线程②调用线程的run()</p>
<p>　 　3.currentThread():静态方法，获取当前的线程</p>
<p>　 　4.getName():获取当前线程的名字</p>
<p>　 　5.setName(String name)：设置当前线程的名字</p>
<p>　 　6.yield():当前线程调用此方法，释放CPU的执行权</p>
<p>　 　7.join():在线程a中调用线程b的join()方法:只用当线程b执行结束以后，线程a结束阻塞状态，继续执行。</p>
<p>　　 8.sleep(long millitimes):让当前的线程睡眠millitimes毫秒</p>
<p>　 　9.isAlive():判断当前线程是否存活 </p>
<p>　　10.线程的优先级：</p>
<p>　　　　 MAX_PRIORITY：10 </p>
<p>　　　　NORM_PRIORITY：5 —默认优先级</p>
<p>　　　　MIN_PRIORITY：1</p>
<p>​    　 设置优先级：setPriority(int priority); </p>
<p>​    　 获取优先级：getPriority()；</p>
<blockquote>
<p>设置优先级以后，对高优先级，使用优先调度的抢占式策略，抢占低优先级的执行。但是并不意味着高优    先级的线程一定先于低优先级的线程执行，而是从概率上来讲，概率更大而已。</p>
</blockquote>
<p> 线程通信：wait() / notify() / notifyAll()  —-&gt;java.lang.Object类中定义的方法</p>
<h4 id="一：继承Thread的方式"><a href="#一：继承Thread的方式" class="headerlink" title="一：继承Thread的方式"></a>一：继承Thread的方式</h4><p>　　　1.提供一个继承Thread类的子类 </p>
<p>　　　2.重写Thread类run():将创建的线程要执行的操作,声明在run()中 </p>
<p>　　　3.实例化Thread子类</p>
<p>　　　4.调用子类对象的start()方法</p>
<h4 id="创建多线程的方式二"><a href="#创建多线程的方式二" class="headerlink" title="创建多线程的方式二:"></a>创建多线程的方式二:</h4><p>　　　1.创建一个实现Runnable接口的类</p>
<p>　　　2.实现Runnable的run()</p>
<p>　　　3.创建当前实现类的对象</p>
<p>　　　4.将此对象作为参数传递到Thread类的构造器中,创建Thread类的对象</p>
<p>　　　5.通过Thread类的对象调用其start()</p>
<p>对比继承Thread类和实现Runnable接口的方式</p>
<p>　　　1.联系:public class Thread implements Runnable</p>
<p>　　　2.相同点:启动线程,使用的是同一个start()方法</p>
<p>　　　3.对比:实现Runnable接口要好一些. </p>
<p>　原因：①不影响类的继承,因为类是单继承的   </p>
<p>　　　　②针对于有共享数据的操作,更适合使用Runnable的方式 ,换句话说,实现Runnable接口的方式,实现了代                    码和数据的分离</p>
<p>　　　4.面试题:创建多线程有几种方法?     继承Thread类,实现Runnable接口,实现Callable接口,使用线程池</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张。—–使用实现的方式</p>
<p>　　1.问题：出现了重票和错票</p>
<p>　　2.问题出现的原因：一个窗口在没有售完票的情况下，其他的窗口参与进来，操作ticket，导致ticket输出的错            误。</p>
<p>　　3.解决的方案：当某一个窗口完全操作完ticket以后，其他窗口应该才被允许进来，继续操作ticket。</p>
<p>　　4.java如何实现的？同步机制：①同步代码块    ②同步方法 </p>
<p>　　　4.1 同步代码块：</p>
<p>​                 synchronized(同步监视器){</p>
<p>​                       //需要被同步的代码</p>
<p>​               }</p>
<p>　　　说明：需要被同步的代码：即为操作共享数据的代码</p>
<p>　　　　　　共享数据：多个线程共同操作的数据。比如：ticket</p>
<p>　　　　　　同步监视器：俗称：锁。 可以由任何一个类的对象充当。 要求：保证多个线程共用同一把锁！</p>
<p>　　　4.2 同步方法：将操作共享数据的方法，声明为同步的。此方法即为同步方法。</p>
<p>　　　　　使用同步方法解决实现方式的线程安全问题。</p>
<p>　　　　　1.默认的同步方法（非静态的）的锁是：当前对象，也就是this.</p>
<p>　　　　　2.默认的同步方法（静态的）的锁是：当前类本身.</p>
<p>　　　　　　使用同步方法解决继承方式的线程安全问题：</p>
<p>　　　　　注意：继承的方式中，要慎用同步方法。</p>
<p>​        5.好处：线程的同步机制，解决了线程的安全问题。</p>
<p>​        6.劣势：在操作共享数据过程中，是单线程的。</p>
<p>模仿车站买票程序。开启3个窗口卖票。总票数为100张     —–使用实现的方式</p>
<p>　　解决线程安全问题的方式三：ReentrantLock</p>
<p>　　存在线程的安全问题，使用Lock的方式解决线程安全问题。</p>
<p>面试题：同步的方式和Lock的方式，解决线程安全方面的异同？</p>
<p>　　同：解决了线程安全问题</p>
<p>　　异：同步的方式：同步监视器在线程执行完操作共享数据的代码以后，自动释放</p>
<blockquote>
<p> Lock的方式：需要显式的调用unlock()方法之后，才能保证其他线程操作共享数据。 </p>
</blockquote>
<p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，是我们开发中需要规避的！</p>
<p>线程的通信：</p>
<ul>
<li><p>wait():一个线程在执行过程中，一旦调用此方法，则此线程进入阻塞状态，等待其他线程来唤醒自己。    </p>
</li>
<li><p>notify():一个线程在执行过程中，一旦调用此方法，则会唤醒被wait()的一个线程。高优先级的要优先被唤醒。</p>
</li>
<li><p>notifyAll():一个线程在执行过程中，一旦调用此方法，则会唤醒所有被wait()的线程。</p>
</li>
</ul>
<p>　　　例题：使用两个线程打印 1-100. 线程1, 线程2 交替打印</p>
<p>注意点：1.此三个方法必须使用在同步中。</p>
<p>　　　　2.此三个方法的调用者是同步监视器！否则，如果三个方法的调用者不是同步监视器，报异常。</p>
<p>　　　　3.此三个方法定义在Object类</p>
<p>面试题：sleep() 和  wait() 的异同？</p>
<p>　　1.方法声明在哪？ Thread:sleep()   Object:wait()</p>
<p>　　2.共同点：使得当前线程进入阻塞状态</p>
<p>　　3.使用的范围要求：sleep()使用没有情境的要求；wait()必须使用在同步代码块或同步方法中</p>
<p>　　4.都使用在同步当中的话：wait()需要唤醒：notify()/notifyAll();  sleep():不会释放锁；wait()会释放锁 </p>
<p> String:字符串</p>
<p>　　　1.字符串声明的数据，会存储在字符串常量池中。第一次声明时，需要创建相应的字符串。之后，如果声明的变量，其值与之前存在的字符串内容相同，则直接引用现成的字符串。</p>
<p>　　　2.面试题：String s3 = new String(“javaEE”);创建的对象，在内存中生成了几个对象？</p>
<p><strong>String:代表着不可变的字符序列。</strong></p>
<p>　　　1.String类的声明public final class String implements java.io.Serializable, Comparable<String>, 　　　　CharSequence</String></p>
<p>　　　　　①String声明为final，不可被继承。</p>
<p>　　　　　②实现Serializable：表明String可序列化。浏览器/客户端&lt;—&gt;服务器端     进程1&lt;—-&gt;进程2    　　　　　　“{name=Tom,age=12}”    JSON:本质就是String</p>
<p>　　　　　③String重写了hashCode()/equals():常常将Map的key声明为String型。</p>
<p>　　　　　④实现Comparable接口：String可以比较大小。</p>
<p>　　　　　⑤实现CharSequence接口：String的底层声明了char[] value数组。</p>
<p>　　　2.如何理解String的不可变性：</p>
<p>　　　　　①向现有的字符串后添加新的字符串，必须声明新的字符串空间</p>
<p>　　　　　②将现有的字符串替换为新的字符串，必须声明新的字符串空</p>
<p>　　　　　③只替换现有字符串中的指定某个字符，也必须声明新的字符串空间</p>
<p>String类与其它结构的转换：</p>
<p>　　　1.String 与包装类、基本数据类型变量间的转换    </p>
<p>　　　　String–&gt;包装类、基本数据类型:调用包装类Xxx的parseXxx(String s)方法</p>
<p>　　　　包装类、基本数据类型 –&gt;String:调用String的valueOf(xxx xxx); </p>
<p>　　　2.String 与 字节数组间的转换   </p>
<p>　　　　String –&gt; 字节数组:调用String类的getBytes()</p>
<p>　　　　字节数组–&gt;String:new String(byte[] buffer,startIndex,length)</p>
<p>　　　3.String 与 字符数组间的转换</p>
<p>　　　　String –&gt; 字符数组：调用String类的toCharArray()</p>
<p>　　　　字符数组 –&gt;String:new String(char[] cbuf,startIndex,length)    </p>
<p>​         </p>
<ul>
<li><p>public String substring(int startpoint):返回当前字符串中从startPoint位置开始，到末尾的子字符串。  </p>
</li>
<li><p>public String substring(int start,int end):返回当前字符串中从startPoint位置开始，到end结束的左闭右开区间的子字符串。</p>
</li>
<li><p>pubic String replace(char oldChar,char newChar):将字符串中指定的所有oldChar替换为newChar.</p>
</li>
<li><p>public String replaceAll(String old,String new):将字符串中指定的所有old替换为new.</p>
</li>
<li><p>public String trim():去除字符串首尾的空格</p>
</li>
<li><p>public String concat(String str):连接两个字符串</p>
</li>
<li><p>public boolean contains(CharSequence s)：判断当前字符串中是否包含s.</p>
</li>
<li><p>public String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。</p>
</li>
</ul>
<ul>
<li><p>public int length():返回当前字符串的长度</p>
</li>
<li><p>public char charAt(int index)：获取指定索引位置的字符</p>
</li>
<li><p>public boolean equals(Object anObject)：比较两个字符串内容是否相等。</p>
</li>
<li><p>public int compareTo(String anotherString):比较两个字符串的大小</p>
</li>
<li><p>public int indexOf(String s):返回s在当前字符串中首次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int indexOf(String s ,int startpoint):</p>
</li>
<li><p>public int lastIndexOf(String s):返回s在当前字符串中末次出现的位置。如果不存在，返回-1.</p>
</li>
<li><p>public int lastIndexOf(String s ,int startpoint):</p>
</li>
<li><p>public boolean startsWith(String prefix)：判断当前的字符串是否以指定的prefix字符串开始的</p>
</li>
<li><p>public boolean endsWith(String suffix)：判断当前的字符串是否以指定的suffix字符串结束的</p>
</li>
<li><p>public boolean regionMatches(int firstStart,String other,int otherStart ,int length)   ？</p>
</li>
</ul>
<p>面试题：</p>
<p>　　String:不可变的字符序列；底层使用char[]存储</p>
<p>　　StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储  </p>
<p>　　StringBuilder:可变的字符序列；线程不安全的，效率高，(jdk 5.0新增)；底层使用char[]存储</p>
<p>类比：String —&gt;数组； StringBuffer —&gt;Vector   StringBuilder —&gt;ArrayList</p>
<p>　　　ArrayList list = new ArrayList();</p>
<p>　　　list.add(123);//new Object[10];</p>
<p>　　　….</p>
<p>　　　扩容:1.5倍的方式扩容。</p>
<p>　　　这里：</p>
<p>　　　　String str = new String();//new char[0];</p>
<p>　　　　str.length();</p>
<p>　　　　String str1 = new String(“abc”);//new char[]{‘a’,’b’,’c’};</p>
<p>　　　对比：</p>
<p>　　　　StringBuffer s1 = new StringBuffer();//char[] value = new char[16]</p>
<p>　　　　StringBuffer s2 = new StringBuffer(10);//char[] value = new char[10]</p>
<p>　　　　s1.append(“abc”);//value[0] = ‘a’,value[1] = ‘b’,value[2] = ‘c’;</p>
<p>　　　　　… </p>
<p>　　　　　　  每次添加时，都需要判断底层的char[]是否能够盛装下新要添加的字符串。</p>
<p>　　　　　　 如果不能盛装下，需要扩容。默认扩容为原来的2倍 + 2.   </p>
<p>　　　 启示：StringBuffer s1 = new StringBuffer(int capacity);开发中建议使用此构造器。</p>
<p>StringBuffer中的方法：</p>
<ul>
<li><p>StringBuffer append(String s),</p>
</li>
<li><p>StringBuffer append(int n) ,</p>
</li>
<li><p>StringBuffer append(Object o) ,</p>
</li>
<li><p>StringBuffer append(char n)，</p>
</li>
<li><p>StringBuffer append(long n),</p>
</li>
<li><p>StringBuffer append(boolean n),</p>
</li>
<li><p>StringBuffer insert(int index, String str)</p>
</li>
<li><p>public StringBuffer reverse()</p>
</li>
<li><p>StringBuffer delete(int startIndex, int endIndex):删除当前可变字符串中从startIndex到endIndex结束的左闭右开区间的数据。</p>
</li>
<li><p>public char charAt(int n )</p>
</li>
<li><p>public void setCharAt(int n ,char ch)</p>
</li>
<li><p>StringBuffer replace( int startIndex ,int endIndex, String str)</p>
</li>
<li><p>public int indexOf(String str)</p>
</li>
<li><p>public String substring(int start,int end)</p>
</li>
<li><p>public int length()</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　增：append(Xxx xxx)</p>
<p>　　删：delete(int startIndex, int endIndex</p>
<p>　　改：setCharAt(int n ,char ch) / replace( int startIndex ,int endIndex, String str)</p>
<p>　　查：charAt(int n)</p>
<p>　　插：insert(int index, String str)</p>
<p>　　长度：length()</p>
<p>　　遍历：使用for + charAt()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/11/1/12/day21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="顾思君">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思君の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/11/1/12/day21/" class="post-title-link" itemprop="url">day21</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 20:12:57" itemprop="dateCreated datePublished" datetime="2020-02-11T20:12:57+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 13:21:40" itemprop="dateModified" datetime="2020-02-12T13:21:40+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、NIO的使用中两个重要的要素：</p>
<p>　缓冲区(Buffer)、通道(Channel)</p>
<p>　缓冲区(Buffer):存储数据的。   —-&gt;byte[] buffer = new byte[1024]</p>
<p>　通道(Channel)：代表着数据源与目标节点之间的连接，负责缓冲区的传输。 —&gt;IO流</p>
<p>　二者的交互：Java NIO 中的 Buffer 主要用于与 NIO 通道(Channel)进行交互， 数据是从通道读入缓冲  区，　从缓冲区写入通道中的。</p>
<p>二、缓冲区（Buffer）的结构 (除boolean之外) </p>
<p>　java.nio.Buffer抽象类</p>
<p>　　|—-ByteBuffer</p>
<p>　　|—-CharBuffer</p>
<p>　　|—-ShortBuffer</p>
<p>　　|—-IntBuffer</p>
<p>　　|—-LongBuffer</p>
<p>　　|—-FloatBuffer</p>
<p>　　|—-DoubleBuffer</p>
<p> XxxBuffer底层使用xxx[]进行存储。</p>
<p> 三、如何实例化缓冲区？调用缓冲区类XxxBuffer的静态方法：allocate(int capacity)   </p>
<p>　　举例：ByteBuffer byteBuffer = ByteBuffer.allocate(10);byte[] hb = new byte[10];</p>
<p>　　类似：ArrayList list = new ArrayList(10);//Object[] eleData = new Object[10];</p>
<p>　说明：方法的形参，决定了底层创建的数组的长度</p>
<p>四、Buffer中的常用属性：</p>
<p>　　capacity:容量，决定了底层数组的长度，表明了最大存储数据的容量</p>
<p>　　limit:限制，默认情况下，limit等于capacity.在读数据模式下，limit&lt;=capacity.表明最大可以读取数据的量position:位置，表明了当前读取或写入数据的位置</p>
<p>　　mark:标记。默认值为-1.</p>
<p>　　关系式：mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>　　类比：项目三中TeamService类中的属性：</p>
<p>　　　private final int MAX_MEMBER = 5;//相当于capacity  </p>
<p>　　　private Programmer[] team = new Programmer[MAX_MEMBER];//Buffer底层封装的数组  </p>
<p>　　　private int total;//相当于limit</p>
<p>　　　index:读取、写入数组指定为的索引：position</p>
<p>五、Buffer中的常用方法：</p>
<p>　　1）最基本的两个方法：put(Xxx xxx) / get()</p>
<p>　　2）其他方法：见ppt中的表格即可。</p>
<p> 六、针对于ByteBuffer来讲，可以创建非直接缓冲区：allocate(int capacity)</p>
<p>​         直接缓冲区：allocateDirect(int capacity) / FileChannel 的 map()</p>
<blockquote>
<p>了解非直接缓冲区 与 直接缓冲区的区别</p>
</blockquote>
<p>byteBuffer.put(“hello”.getBytes());//写入长度为5的字节数.每put一个字节，position就+1</p>
<p>byteBuffer.flip();//切换为读数据模式。将limit设置为position，position归零</p>
<p>byteBuffer.rewind();//重置position</p>
<p>byteBuffer.clear();//清空.将position归零，limit设置为capacity.数据并未删除。</p>
<p>byteBuffer.get(dst,0,2);//从数组角标0开始，写入两个字节的数组</p>
<p>if(byteBuffer.hasRemaining()){</p>
<p>//判断是否还有元素没有读取到。   </p>
<p>​        System.out.println(byteBuffer.remaining());//还有几个没有读取到。</p>
<p>   }System.out.println();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="顾思君"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">顾思君</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gusijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gusijun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/nightmare_dimple" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;nightmare_dimple" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">古俊</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">72k</span>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
